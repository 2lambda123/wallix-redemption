\documentclass[11pt]{report}
\title{\textbf{ReDemPtion C++ Coding Guidelines}}
\author{Christophe Grosjean}
\date{30/01/2013}
\usepackage{listings} % http://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings
%\lstset{language=C++}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{ %
  language=C++,                   % the language of the code
  backgroundcolor=\color{white},  % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,       % the size of the fonts that are used for the code
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  breaklines=true,                % sets automatic line breaking
  captionpos=b,                   % sets the caption-position to bottom
  commentstyle=\color{dkgreen},   % comment style
  deletekeywords={...},           % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},         % if you want to add LaTeX within your code
  frame=L,                        % adds a frame around the code
  keywordstyle=\color{blue},      % keyword style
  morekeywords={*,...},           % if you want to add more keywords to the set
  numbers=none,                   % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                  % how far the line-numbers are from the code
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,               % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,         % underline spaces within strings only
  showtabs=false,                 % show tabs within strings adding particular underscores
  stepnumber=2,                   % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mauve},      % string literal style
  tabsize=4,                      % sets default tabsize to 4 spaces
  title=\lstname                  % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\begin{document}

\maketitle

\chapter{Before we start}

\section{Disclaimer}

This document is based on Google C++ Coding Guidelines, to which I basically agree. Hence many paragraphs belons tp their respective authors. I encourage readers to check the original \emph{Google C++ Style Guide}\footnote{http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml}, which I believe is an enlitghtning reading.

However there is differences between the way I'm currently writing code in ReDemPtion project and those guidelines. So, I felt I had to review all of it's content and modify it to what I really wished. I revendicate evil ideas as mine, mostly perversion of the original good content. I also added some brand new content not addressed by original document. Mostly, it about the way the C++ code relates to external world and tools (building and testing tools, contain management and such).

Some conventions used by ReDemPtion projects exists for historical reasons and may evolve in the future. Others are related to code management, performances, statical check or code generation issues and were introduced deliberately event if they may seems unusual or disturbing at once. There is even projects to port part of the code base to some other languages (hint: I love D). Again some current rules may (and should) evolve in the future.

Good or bad theses coventions are (yet) an ideal and many parts of the code must be fixed, hence they are only mandatory for new of modified source code.


\section{Background}

C++ is the main development language used by ReDemPtion project. As every C++ programmer knows, the language has many powerful features, but this power brings with it complexity, which in turn can make code more bug-prone and harder to read and maintain.

The goal of this guide is to manage this complexity by describing in detail the dos and don'ts of writing C++ code. These rules exist to keep the code base manageable while still allowing coders to use C++ language features productively.

Style, also known as readability, is what we call the conventions that govern our C++ code. The term Style is a bit of a misnomer, since these conventions cover far more than just source file formatting. Many parts are even not about C++ language at all, but about software design rules like how to write unit tests or which code smells should be avoided and how the code should be refactored if such a smell is detected.

One way in which we keep the code base manageable is by enforcing consistency. It is very important that any programmer be able to look at another's code and quickly understand it. Maintaining a uniform style and following conventions means that we can more easily use "pattern-matching" to infer what various symbols are and what invariants are true about them. Creating common, required idioms and patterns makes code much easier to understand. In some cases there might be good arguments for changing certain style rules, but we nonetheless keep things as they are in order to preserve consistency.

Another issue this guide addresses is that of C++ feature bloat. C++ is a huge language with many advanced features. In many cases we constrain, or even ban, use of certain features. We do this to keep code simple and to avoid the various common errors and problems that these features can cause. This guide lists these features and explains why their use is restricted. Be warned \emph{large} parts of C++ are frowned upon in these guide : STL, templates, function overloading, etc.


Note that this guide is not a C++ tutorial: we assume that the reader is familiar with the language.

\chapter{Build Environment}

\chapter{Header Files}

In general, every .cpp file should have an associated .hpp file. There are some common exceptions, such as unittests and small .cpp files containing just a main() function.

Correct use of header files can make a huge difference to the readability, size and performance of your code.

The following rules will guide you through the various pitfalls of using header files. 

\section{The define Guard}

All header files should have \#define guards to prevent multiple inclusion. To guarantee uniqueness the format of the symbol name should be:
\vspace{5pt}
\begin{lstlisting}[frame=none]
<PROJECT>_<PATH>_<FILE>_HPP_
\end{lstlisting}
\vspace{-20pt}
 \lstinline{}

The given path should be the full path in the source tree and the define name will be fully capitalized. In some rare case there may be some name collision with the above scheme if the source name containes underscore or if several files with different capitalization exists in tre source tree. We will ignore these cases it's the responsibility of the coder to ensure it does not happen.

\vspace{5pt}
\begin{lstlisting}
#ifndef FOO_BAR_BAZ_HPP_
#define FOO_BAR_BAZ_HPP_
\end{lstlisting}
\vspace{-20pt}


\section{Forward Declarations}

Forward declaration of classes should be avoided. 

\subsection{Definition:} A \"forward declaration\" is a declaration of a class, function, or template without an associated definition. \#include lines can often be replaced with forward declarations of whatever symbols are actually used by the client code.

\subsection{Pros:}

Unnecessary \#includes force the compiler to open more files and process more input.
    They can also force your code to be recompiled more often, due to changes in the header.

\subsection{Cons:}

    It can be difficult to determine the correct form of a forward declaration in the presence of features like templates, typedefs, default parameters, and using declarations.
    It can be difficult to determine whether a forward declaration or a full \#include is needed for a given piece of code, particularly when implicit conversion operations are involved. In extreme cases, replacing an \#include with a forward declaration can silently change the meaning of code.
    Forward declaring multiple symbols from a header can be more verbose than simply \#include-ing the header.
    Forward declarations of functions and templates can prevent the header owners from making otherwise-compatible changes to their APIs; for example, widening a parameter type, or adding a template parameter with a default value.
    Forward declaring symbols from namespace std:: usually yields undefined behavior.
    Structuring code to enable forward declarations (e.g. using pointer members instead of object members) can make the code slower and more complex.
    The practical efficiency benefits of forward declarations are unproven.

\subsection{Decision:}

    When using a function declared in a header file, always \#include that header.
    When using a class template, prefer to \#include its header file.
    When using an ordinary class forward declaration should be avoided. There are situations where a forward declaration may be insufficient or incorrect preferably just \#include the appropriate header.
    Do not replace data members with pointers just to avoid an \#include.

Always \#include the file that actually provides the declarations/definitions you need; do not rely on the symbol being brought in transitively via headers not directly included. One exception is that myfile.cpp may rely on \#includes and forward declarations from its corresponding header file myfile.hpp.

\section{Inline Functions}

inline function is a misleading name. It is related to compilation unit more than actually inlining. All functions and methods should be inlined when using headers-only style or linking problems will occur.

\subsection{Definition:} You can declare functions in a way that tells the compiler that the same function definition can appear in several compilation units. The used keyword is inline and is also a hint for the compiler to inline the code (but this is not mandatory and compilers will do as they wish).

\subsection{Pros:} Inlining a function can generate more efficient object code, as long as the inlined function is small. Typical use is to inline accessors and mutators, and other short, performance-critical functions.
Inlining a function avoids keeping two independant header lines one in header, the other in implementation file. This is a burden when refactoring loop.
Making a function inline place its definition in the class, which is convenient and document its behavior, e.g., for accessors and mutators. 

Inline is mandatory when using headers only style as soon as we have several compilation units, or prtogram won't link (multiple definitions of the same symbol).

It is important to know that functions are not always inlined even if they are declared as such; for example, virtual and recursive functions are not normally inlined. Usually recursive functions should not be inline. Modern compilers may often choose not to inline code even hinted with the inline keyword in inefficient cases (like when the inlined function contains loops or switch statements).

\subsection{Cons:} Overuse of inlining can actually make programs slower. Depending on a function's size, inlining it can cause the code size to increase or decrease. Inlining a very small accessor function will usually decrease code size while inlining a very large function can dramatically increase code size. On modern processors smaller code usually runs faster due to better use of the instruction cache.
Inlining makes headers files larger and leads to slower compilation times. 
The header will also be changed more often which will also lead to longer compilation times.

\subsection{Decision:} Inlining should be used with headers only style, unless there is a mesurable performance issue doing otherwise is best.

When a class API is stabilized and the class is ready to become an independant library (not headers library), header file should be refactored and inlined functions shortened and code moved to implementation .cpp file.


\chapter{Unit Testing}

\chapter{Code Smells}

\chapter{Scoping}

\chapter{Other C++ Features}

\chapter{Naming}

\chapter{Comments}

\chapter{Formatting}

\end{document}
