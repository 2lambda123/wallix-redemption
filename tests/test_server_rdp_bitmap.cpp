/*
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

   Product name: redemption, a FLOSS RDP proxy
   Author(s): Christophe Grosjean

   Module: test_server_rdp_bitmap.cpp
   Description : sample minimal automated answering rdp software

   This code is not production code. It is used to test compatibility
   with RDP client software through core server_rdp layer. This code
   issue the simple minimal drawing orders sequences we want to test.

*/

#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <poll.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>
#include "stream.hpp"
#include "config.hpp"
#include "transport.hpp"
#include "server_rdp.hpp"
#include "orders.hpp"
#include "client_info.hpp"
#include "font.hpp"
#include "cache.hpp"
#include "bitmap.hpp"
#include "file_loc.hpp"
#include "rsa_keys.hpp"
#include "wait_obj.hpp"
#include "log.hpp"
#include "front.hpp"
#include "check_files.hpp"

typedef enum {
    STATE_RSA_KEY_HANDSHAKE,
    STATE_ENTRY,
    STATE_RUNNING,
    STATE_STOP
} t_internal_state;

t_internal_state step_STATE_RUNNING(struct timeval & time,
                                    int sck,
                                    RDP::Orders * orders,
                                    Cache * cache,
                                    Font * font,
                                    ClientInfo * client_info,
                                    Front * front)
{
    cout << "sending orders\n";
    const RDPBrush brush;
//    orders->init();
    Colors color(24);
//    orders->opaque_rect(Rect(0, 0, 34, 34), color.pink, Rect(0, 0, 34, 34));

    const uint8_t cache_id = 0;
    const uint8_t cache_idx = 0;

#define PIXWHITE 0xFF, 0xFF, 0xFF
#define PIX4WHITE PIXWHITE, PIXWHITE, PIXWHITE, PIXWHITE
#define PIX8WHITE PIX4WHITE, PIX4WHITE
#define PIX32WHITE PIX8WHITE, PIX8WHITE, PIX8WHITE, PIX8WHITE

#define PIXBLUE 0xFF, 0x00, 0x00
#define PIX4BLUE PIXBLUE, PIXBLUE, PIXBLUE, PIXBLUE
#define PIX8BLUE PIX4BLUE, PIX4BLUE
#define PIX32BLUE PIX8BLUE, PIX8BLUE, PIX8BLUE, PIX8BLUE

#define PIX32BLUEWHITE PIX8BLUE, PIX8BLUE, PIX8WHITE, PIX8WHITE
#define PIX32WHITEBLUE PIX8WHITE, PIX8WHITE, PIX8BLUE, PIX8BLUE


//    uint8_t data[32*32*3] = {
//        PIX32BLUEWHITE, PIX32BLUEWHITE, PIX32BLUEWHITE, PIX32BLUEWHITE,
//        PIX32BLUEWHITE, PIX32BLUEWHITE, PIX32BLUEWHITE, PIX32BLUEWHITE,
//        PIX32BLUEWHITE, PIX32BLUEWHITE, PIX32BLUEWHITE, PIX32BLUEWHITE,
//        PIX32BLUEWHITE, PIX32BLUEWHITE, PIX32BLUEWHITE, PIX32BLUEWHITE,

//        PIX32WHITEBLUE, PIX32WHITEBLUE, PIX32WHITEBLUE, PIX32WHITEBLUE,
//        PIX32WHITEBLUE, PIX32WHITEBLUE, PIX32WHITEBLUE, PIX32WHITEBLUE,
//        PIX32WHITEBLUE, PIX32WHITEBLUE, PIX32WHITEBLUE, PIX32WHITEBLUE,
//        PIX32WHITEBLUE, PIX32WHITEBLUE, PIX32WHITEBLUE, PIX32WHITEBLUE
//    };


    uint8_t data[32*32*3] = {
        PIX32BLUE, PIX32BLUE, PIX32BLUE, PIX32BLUE,
        PIX32BLUE, PIX32BLUE, PIX32BLUE, PIX32BLUE,
        PIX32BLUE, PIX32BLUE, PIX32BLUE, PIX32BLUE,
        PIX32BLUE, PIX32BLUE, PIX32BLUE, PIX32BLUE,

        PIX32BLUE, PIX32BLUE, PIX32BLUE, PIX32BLUE,
        PIX32BLUE, PIX32BLUE, PIX32BLUE, PIX32BLUE,
        PIX32BLUE, PIX32BLUE, PIX32BLUE, PIX32BLUE,
        PIX32BLUE, PIX32BLUE, PIX32BLUE, PIX32BLUE,
    };


//    // color encoding is BGR
//    orders->send_raw_bitmap(32, 32, 24, data, cache_id, cache_idx);

//    orders->mem_blt(cache_id, 0, Rect(1, 1, 30, 30), 0xcc, 30, 30, 2, 2, cache_idx, Rect(0, 0, 34, 34));
//    orders->send();

    Colors colors(client_info->bpp);
    front->colors = colors;

#define COLOR_IMAGE FIXTURES_PATH "/color_image2.bmp"
    Bitmap bgbmp(COLOR_IMAGE, front->colors.bpp);

#define LOGO FIXTURES_PATH "/logo-redemption.bmp"
    Bitmap logobmp(LOGO, front->colors.bpp);

//#define LOGO2 FIXTURES_PATH "/logo-truncated-16x2.bmp"
//    Bitmap logobmp2(LOGO2, colors.bpp);

    {
        front->begin_update();
        #warning it is not necessary to send all the bitmap, sending the clipped region would be enough
        front->send_bitmap_front(
            Rect(0, 0, bgbmp.cx, bgbmp.cy),
            Rect(0, 0, bgbmp.cx, bgbmp.cy),
           (uint8_t*)bgbmp.data_co,
           colors, 0, Rect(0, 0, bgbmp.cx, bgbmp.cy));
        front->end_update();
    }

//    {
//        front->begin_update();
//        #warning it is not necessary to send all the bitmap, sending the clipped region would be enough
//        front->send_bitmap_front(
//            Rect(0, 0, logobmp.cx, logobmp.cy),
//            Rect(0, 0, logobmp.cx, logobmp.cy),
//           (uint8_t*)logobmp.data_co,
//           colors, 0, Rect(0, 0, 800, 600));
//        front->end_update();
//    }

    /* 3910 */

    uint8_t compressed_i0_j0[] = {
0x0c, 0x81, 0x0a, 0x0a, 0xc8, 0xc0, 0x03, 0x0c, 0x0c, 0xea, 0x81, 0x05, 0x05, 0x64, 0x0e, 0x83,
0x00, 0x00, 0x06, 0x04, 0x04, 0x5d, 0x0a, 0x0a, 0xd2, 0x2e, 0x0c, 0x81, 0x08, 0x08, 0x9e, 0x13,
0x81, 0x07, 0x07, 0x8e, 0x70, 0x00, 0x00, 0x00, 0x82, 0x01, 0x01, 0x15, 0x09, 0x09, 0xb1, 0x19,
0x81, 0x06, 0x06, 0x75, 0x13, 0x81, 0x09, 0x09, 0xb7, 0x71, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00,
0x03, 0x08, 0x08, 0xa2, 0x18, 0x81, 0x03, 0x03, 0x4c, 0x13, 0x81, 0x0b, 0x0b, 0xdf, 0x72, 0x00,
0x00, 0x00, 0x82, 0x00, 0x00, 0x0d, 0x0a, 0x0a, 0xc8, 0x17, 0x81, 0x01, 0x01, 0x23, 0x74, 0x0c,
0x0c, 0xea, 0x81, 0x01, 0x01, 0x20, 0x72, 0x00, 0x00, 0x00, 0x81, 0x02, 0x02, 0x35, 0x17, 0x82,
0x00, 0x00, 0x02, 0x0b, 0x0b, 0xe2, 0x13, 0x81, 0x03, 0x03, 0x4a, 0x73, 0x00, 0x00, 0x00, 0x81,
0x09, 0x09, 0xb2, 0x16, 0x82, 0x00, 0x00, 0x00, 0x09, 0x09, 0xbc, 0x13, 0x81, 0x05, 0x05, 0x73,
0x13, 0x81, 0x03, 0x03, 0x47, 0x17, 0x81, 0x07, 0x07, 0x92, 0x13, 0x81, 0x08, 0x08, 0x9d, 0x13,
0x82, 0x00, 0x00, 0x09, 0x0b, 0x0b, 0xe6, 0x16, 0x81, 0x05, 0x05, 0x69, 0x13, 0x81, 0x0a, 0x0a,
0xc7, 0x74, 0x00, 0x00, 0x00, 0x81, 0x09, 0x09, 0xb9, 0x16, 0x81, 0x03, 0x03, 0x40, 0x13, 0x82,
0x0b, 0x0b, 0xe8, 0x00, 0x00, 0x08, 0x13, 0x81, 0x06, 0x06, 0x85, 0x16, 0x81, 0x01, 0x01, 0x16,
0x74, 0x0c, 0x0c, 0xea, 0x81, 0x02, 0x02, 0x2f, 0x13, 0x81, 0x05, 0x05, 0x71, 0x16, 0x82, 0x00,
0x00, 0x00, 0x0b, 0x0b, 0xd8, 0x13, 0x81, 0x04, 0x04, 0x59, 0x13, 0x81, 0x04, 0x04, 0x61, 0x17,
0x81, 0x08, 0x08, 0xaf, 0x13, 0x81, 0x06, 0x06, 0x83, 0x13, 0x81, 0x04, 0x04, 0x51, 0x17, 0x81,
0x06, 0x06, 0x85, 0x13, 0x81, 0x08, 0x08, 0xac, 0x13, 0x81, 0x04, 0x04, 0x5a, 0x17, 0x81, 0x04,
0x04, 0x5c, 0x13, 0x81, 0x0b, 0x0b, 0xd6, 0x13, 0x81, 0x05, 0x05, 0x6e, 0x17, 0x81, 0x02, 0x02,
0x33, 0x74, 0x0c, 0x0c, 0xea, 0x81, 0x01, 0x01, 0x15, 0x12, 0x81, 0x08, 0x08, 0x9f, 0x17, 0x82,
0x00, 0x00, 0x0b, 0x0b, 0x0b, 0xe9, 0x13, 0x81, 0x03, 0x03, 0x3e, 0x11, 0x82, 0x00, 0x00, 0x09,
0x0b, 0x0b, 0xdb, 0x17, 0x82, 0x00, 0x00, 0x00, 0x0a, 0x0a, 0xcb, 0x13, 0x81, 0x05, 0x05, 0x68,
0x11, 0x81, 0x05, 0x05, 0x6f, 0x6a, 0x0c, 0x0c, 0xea, 0x0f, 0x81, 0x08, 0x08, 0xa2, 0x13, 0x81,
0x07, 0x07, 0x91, 0x10, 0x82, 0x03, 0x03, 0x3c, 0x0b, 0x0b, 0xe3, 0x19, 0x81, 0x06, 0x06, 0x79,
0x13, 0x81, 0x09, 0x09, 0xbc, 0x0e, 0x83, 0x00, 0x00, 0x02, 0x05, 0x05, 0x69, 0x0b, 0x0b, 0xe0,
0x6b, 0x0c, 0x0c, 0xea, 0x0f, 0x81, 0x04, 0x04, 0x4f, 0x13, 0x82, 0x0b, 0x0b, 0xe2, 0x00, 0x00,
0x02, 0x0a, 0x84, 0x01, 0x01, 0x14, 0x03, 0x03, 0x3f, 0x06, 0x06, 0x7c, 0x0a, 0x0a, 0xd0, 0x6d,
0x0c, 0x0c, 0xea, 0x0f, 0x81, 0x01, 0x01, 0x26, 0x74, 0x0c, 0x0c, 0xea, 0xc8, 0x0a, 0x0a, 0xc9,
0x83, 0x0a, 0x0a, 0xca, 0x0b, 0x0b, 0xd6, 0x0b, 0x0b, 0xe2, 0x71, 0x0c, 0x0c, 0xea, 0x0f, 0x82,
0x00, 0x00, 0x03, 0x0b, 0x0b, 0xe4, 0x60, 0x0f, 0x0c, 0x0c, 0xea, 0x70, 0x00, 0x00, 0x00, 0x81,
0x09, 0x09, 0xbf, 0x00, 0x1f, 0x81, 0x07, 0x07, 0x96, 0x00, 0x1f, 0x81, 0x05, 0x05, 0x6d, 0x00,
0x1f, 0x81, 0x03, 0x03, 0x43, 0x00, 0x1f, 0x81, 0x01, 0x01, 0x1a, 0x00, 0x1f, 0x82, 0x00, 0x00,
0x00, 0x0b, 0x0b, 0xdb, 0x00, 0x1f, 0x81, 0x09, 0x09, 0xb2, 0x00, 0x1f, 0x81, 0x07, 0x07, 0x89,
0x00, 0x1f, 0x81, 0x04, 0x04, 0x60, 0x00, 0x1f, 0x81, 0x02, 0x02, 0x37, 0x00, 0x1f, 0x81, 0x00,
0x00, 0x0e, 0x00, 0x1f, 0x82, 0x00, 0x00, 0x00, 0x0a, 0x0a, 0xcf, 0x00, 0x0c, 0x81, 0x0a, 0x0a,
0xcf, 0x12, 0x81, 0x08, 0x08, 0xa6, 0x00, 0x09, 0x84, 0x0b, 0x0b, 0xde, 0x07, 0x07, 0x9b, 0x03,
0x03, 0x4a, 0x00, 0x00, 0x02, 0x12, 0x81, 0x06, 0x06, 0x7c, 0x00, 0x04, 0x86, 0x0b, 0x0b, 0xe8,
0x0a, 0x0a, 0xcb, 0x08, 0x08, 0xa6, 0x05, 0x05, 0x71, 0x03, 0x03, 0x3b, 0x00, 0x00, 0x07, 0x75,
0x00, 0x00, 0x00, 0x81, 0x02, 0x02, 0x2c, 0xc0, 0x0d, 0x09, 0x09, 0x9b, 0x88, 0x05, 0x05, 0x70,
0x05, 0x05, 0x6b, 0x05, 0x05, 0x64, 0x04, 0x04, 0x5e, 0x04, 0x04, 0x4e, 0x03, 0x03, 0x3a, 0x01,
0x01, 0x25, 0x00, 0x00, 0x07, 0xf3, 0x88, 0x06, 0x00, 0x00, 0x00,
    };


    uint8_t compressed_i64_j0[] = {
        0xc0, 0x30, 0x00, 0x00, 0xff,
        0x00, 0x20,
        0x00, 0x20,
        0x00, 0x20,
        0x00, 0x20,
        0x00, 0x20,
        0x00, 0x20,
        0x00, 0x20,

//        0x00, 0x00, 0x01F,
//        0x00, 0x00, 0xff, // MIX SET RED 64
//        0xC0, 0x30, 0xFF, 0xFF, 0x00,
//        0x00, 0x00,
//        0x00, 0x00,
//        0x00, 0x00,
//        0x00, 0x00,
//        0x00, 0x00,
//        0x00, 0x00,
//        0x00, 0x00,

//        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00,

//
//            0x82, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,// 1 COPY RED
//            0x00, 0x1C, // 60 FILL
//            0x82, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF,
//            //    0x1F,  0x1D,    0x81, 0x01, 0x02, 0xFF,


//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40,
//            0x00, 0x40, 0x00, 0x40, 0x00, 0x40,

//    uint8_t compressed_i64_j0[] = {
//0xc6, 0x0c, 0x0c, 0xea, // 6 MIX_SET
//0x81, 0x0a, 0x0a, 0xcd, // 1 COPY
//0xd0, 0x03, 0x00, 0x00, 0x0a, 0x01, // 4 FOM SET
//0x81, 0xb3, 0x25, 0x09, // 1 COPY
//0xc0, 0x06, 0xea, 0x31, 0x0c, // 22 = 16 + 6 MIX_SET
//0x81, 0xde, 0x2e, 0x0b, // 1 COPY
//0x1d, // 29
//0x06,
////0x00, 0x03, // 35

//0x81, 0x0c, 0x0c, 0xea,
//0xd0, 0x03, 0x06, 0x06, 0x7c, 0x01, 0x81, 0x8a, 0x1d, 0x07, 0x77, 0xea, 0x31, 0x0c, 0x81,
//0x1f, 0x06, 0x01, 0x00, 0x03, 0x81, 0x0b, 0x0b, 0xe1, 0xd0, 0x02, 0x01, 0x01, 0x15, 0x01, 0x81,
//0x61, 0x14, 0x04, 0x17, 0x81, 0x49, 0x0f, 0x03, 0x00, 0x03, 0x81, 0x0c, 0x0c, 0xea, 0xd0, 0x02,
//0x07, 0x07, 0x6c, 0x01, 0x81, 0x38, 0x0b, 0x02, 0x17, 0x81, 0x72, 0x18, 0x05, 0x00, 0x04, 0x81,
//0x0b, 0x0b, 0xd8, 0xd0, 0x01, 0x00, 0x00, 0x05, 0x01, 0x81, 0x0f, 0x03, 0x00, 0x17, 0x81, 0x9c,
//0x20, 0x08, 0x00, 0x04, 0x81, 0x0c, 0x0c, 0xea, 0xd0, 0x01, 0x03, 0x03, 0x4d, 0x01, 0x82, 0x00,
//0x00, 0x00, 0xd1, 0x2b, 0x0a, 0x16, 0x81, 0xc6, 0x29, 0x0a, 0x00, 0x05, 0xd0, 0x02, 0x04, 0x04,
//0xd0, 0x01, 0x81, 0xa7, 0x23, 0x08, 0x16, 0x82, 0xe7, 0x30, 0x0b, 0x08, 0x01, 0x00, 0x00, 0x04,
//0xd0, 0x02, 0x0c, 0x0c, 0x4e, 0x01, 0x81, 0x7e, 0x1a, 0x06, 0x77, 0xea, 0x31, 0x0c, 0x81, 0x2e,
//0x09, 0x02, 0x00, 0x04, 0x81, 0x0c, 0x0c, 0xea, 0xd0, 0x01, 0x02, 0x02, 0x29, 0x01, 0x81, 0x55,
//0x11, 0x04, 0x17, 0x81, 0x59, 0x12, 0x04, 0x00, 0x05, 0xd0, 0x01, 0x06, 0x06, 0x71, 0x01, 0x81,
//0x2c, 0x09, 0x02, 0x17, 0x81, 0x82, 0x1b, 0x06, 0x00, 0x05, 0xd0, 0x01, 0x02, 0x02, 0xd9, 0x01,
//0x82, 0x06, 0x01, 0x00, 0xe6, 0x30, 0x0b, 0x16, 0x81, 0xac, 0x24, 0x08, 0x00, 0x05, 0xd0, 0x01,
//0x0e, 0x0e, 0x25, 0x01, 0x82, 0x00, 0x00, 0x00, 0xc4, 0x29, 0x0a, 0x16, 0x81, 0xd5, 0x2c, 0x0a,
//0x00, 0x05, 0xd0, 0x02, 0x01, 0x01, 0x18, 0x01, 0x81, 0x9b, 0x20, 0x07, 0x77, 0xea, 0x31, 0x0c,
//0x81, 0x15, 0x04, 0x01, 0x00, 0x04, 0xd0, 0x02, 0x03, 0x03, 0x6e, 0x01, 0x81, 0x71, 0x17, 0x05,
//0x17, 0x81, 0x3e, 0x0d, 0x03, 0x00, 0x04, 0xd0, 0x02, 0x01, 0x01, 0x0f, 0x01, 0x81, 0x48, 0x0f,
//0x03, 0x17, 0x81, 0x68, 0x15, 0x05, 0x00, 0x04, 0xd0, 0x02, 0x00, 0x00, 0x39, 0x01, 0x81, 0x20,
//0x06, 0x01, 0x17, 0x81, 0x91, 0x1e, 0x07, 0x00, 0x04, 0xd0, 0x02, 0x00, 0x00, 0x03, 0x01, 0x82,
//0x00, 0x00, 0x00, 0xdf, 0x2e, 0x0b, 0x16, 0x81, 0xbc, 0x27, 0x09, 0x00, 0x04, 0xd0, 0x03, 0x00,
//0x00, 0x39, 0x01, 0x81, 0xb8, 0x26, 0x09, 0x16, 0x82, 0xe2, 0x2f, 0x0b, 0x02, 0x00, 0x00, 0x00,
//0x03, 0xd0, 0x03, 0x01, 0x01, 0x0d, 0x01, 0x81, 0x8f, 0x1d, 0x07, 0x77, 0xea, 0x31, 0x0c, 0x81,
//0x23, 0x07, 0x01, 0x00, 0x03, 0xd0, 0x03, 0x03, 0x03, 0x69, 0x01, 0x81, 0x65, 0x15, 0x05, 0x17,
//0x81, 0x4e, 0x10, 0x04, 0x00, 0x03, 0xd0, 0x03, 0x0e, 0x0e, 0x21, 0x01, 0x81, 0x3c, 0x0c, 0x03,
//0x17, 0x81, 0x77, 0x18, 0x06, 0x00, 0x03, 0xd0, 0x03, 0x02, 0x02, 0xe9, 0x01, 0x81, 0x13, 0x04,
//0x00, 0x17, 0x81, 0xa1, 0x21, 0x08, 0x00, 0x03, 0xd0, 0x03, 0x06, 0x06, 0x49, 0x01, 0x82, 0x00,
//0x00, 0x00, 0xd4, 0x2c, 0x0a, 0x16, 0x81, 0xca, 0x2a, 0x0a, 0x00, 0x02, 0x81, 0x0b, 0x0b, 0xe0,
//0xd0, 0x04, 0x03, 0x03, 0x33, 0x01, 0x81, 0xab, 0x23, 0x08, 0x16, 0x82, 0xe9, 0x30, 0x0b, 0x0b,
//0x02, 0x00, 0x00, 0x01, 0x81, 0x07, 0x07, 0x98, 0xd0, 0x04, 0x00, 0x00, 0x08, 0x01, 0x81, 0x82,
//0x1b, 0x06, 0x77, 0xea, 0x31, 0x0c, 0x81, 0x33, 0x0a, 0x02, 0x17, 0x81, 0x56, 0x12, 0x04, 0x09,
//0xd0, 0x05, 0x04, 0x04, 0xd8, 0x01, 0x81, 0x59, 0x12, 0x04, 0x17, 0x81, 0x5d, 0x13, 0x04, 0x14,
//0x83, 0x02, 0x00, 0x00, 0x4b, 0x0f, 0x03, 0xc0, 0x28, 0x09, 0xd0, 0x08, 0xbc, 0x23, 0x08, 0x01,
//0x00, 0x81, 0x09, 0x09, 0xb9, 0xd0, 0x05, 0x03, 0x03, 0x40, 0x01, 0x81, 0x2f, 0x09, 0x02, 0x17,
//0x81, 0x86, 0x1c, 0x06, 0x11, 0x84, 0x01, 0x00, 0x00, 0x2f, 0x09, 0x02, 0x7a, 0x19, 0x06, 0xd1,
//0x2b, 0x0a, 0x63, 0xea, 0x31, 0x0c, 0x08, 0xd0, 0x06, 0x0a, 0x0a, 0x85, 0x01, 0x82, 0x09, 0x01,
//0x00, 0xe8, 0x30, 0x0b, 0x16, 0x81, 0xb1, 0x25, 0x09, 0x0c, 0x86, 0x0e, 0x03, 0x00, 0x25, 0x07,
//0x01, 0x47, 0x0e, 0x03, 0x71, 0x17, 0x05, 0x9d, 0x21, 0x08, 0xd7, 0x2d, 0x0b, 0x66, 0xea, 0x31,
//0x0c, 0x07, 0x81, 0x07, 0x07, 0x8e, 0x68, 0x00, 0x00, 0x00, 0x81, 0xc8, 0x2a, 0x0a, 0x16, 0x81,
//0xe4, 0x2f, 0x0b, 0xc8, 0xc2, 0x28, 0x09, 0x84, 0xc5, 0x29, 0x0a, 0xcd, 0x2b, 0x0a, 0xd4, 0x2c,
//0x0a, 0xe0, 0x2f, 0x0b, 0x6c, 0xea, 0x31, 0x0c, 0x06, 0x81, 0x09, 0x09, 0xbe, 0xd0, 0x08, 0x07,
//0x07, 0x85, 0x01, 0x00, 0x81, 0x9f, 0x21, 0x08, 0x60, 0x0f, 0xea, 0x31, 0x0c, 0x05, 0x82, 0x0a,
//0x0a, 0xce, 0x01, 0x01, 0x19, 0xd0, 0x08, 0x00, 0x00, 0x0b, 0x01, 0x00, 0x81, 0x76, 0x18, 0x06,
//0x00, 0x13, 0x82, 0x0a, 0x0a, 0xc3, 0x01, 0x01, 0x19, 0x6a, 0x00, 0x00, 0x00, 0x81, 0x4d, 0x10,
//0x03, 0x00, 0x12, 0x82, 0x07, 0x07, 0x9a, 0x00, 0x00, 0x0e, 0x6b, 0x00, 0x00, 0x00, 0x81, 0x23,
//0x07, 0x01, 0x00, 0x10, 0x82, 0x0a, 0x0a, 0xd0, 0x04, 0x04, 0x51, 0x6d, 0x00, 0x00, 0x00, 0x82,
//0x02, 0x00, 0x00, 0xe2, 0x2f, 0x0b, 0x00, 0x0e, 0x82, 0x05, 0x05, 0x6b, 0x00, 0x00, 0x08, 0x6f,
//0x00, 0x00, 0x00, 0x81, 0xbc, 0x27, 0x09, 0x00, 0x0e, 0x71, 0x00, 0x00, 0x00, 0x81, 0x92, 0x1e,
//0x07, 0x00, 0x1f, 0x81, 0x69, 0x16, 0x05, 0x00, 0x1f, 0x81, 0x40, 0x0d, 0x03, 0x00, 0x1f, 0x81,
//0x17, 0x04, 0x01, 0x00, 0x1f, 0x82, 0x00, 0x00, 0x00, 0xd9, 0x2d, 0x0b, 0x00, 0x1f, 0x81, 0xb0,
//0x24, 0x09, 0x00, 0x1f, 0x81, 0x86, 0x1c, 0x06, 0x00, 0x1f, 0x81, 0x5d, 0x13, 0x04, 0x00, 0x1f,
//0x81, 0x34, 0x0a, 0x02, 0x00, 0x1f, 0x82, 0x0b, 0x02, 0x00, 0xe9, 0x30, 0x0b, 0x00, 0x1e, 0x82,
//0x00, 0x00, 0x00, 0xcc, 0x2a, 0x0a, 0x00, 0x1f, 0x81, 0xa3, 0x22, 0x08, 0x00, 0x1f, 0x81, 0x7a,
//0x19, 0x06, 0x1e, 0x8e, 0xe4, 0x2f, 0x0b, 0xde, 0x2e, 0x0b, 0xd7, 0x2d, 0x0b, 0xcd, 0x2b, 0x0a,
//0xc2, 0x28, 0x09, 0xb6, 0x26, 0x09, 0xaa, 0x23, 0x08, 0x9a, 0x20, 0x07, 0x88, 0x1c, 0x07, 0x78,
//0x19, 0x06, 0x63, 0x14, 0x05, 0x4b, 0x0f, 0x03, 0x32, 0x0a, 0x02, 0x17, 0x04, 0x01, 0x13, 0x81,
//0x05, 0x01, 0x00, 0xc0, 0x08, 0xe4, 0x32, 0x0c, 0x85, 0x0d, 0x02, 0x00, 0x0b, 0x02, 0x00, 0x0a,
//0x02, 0x00, 0x07, 0x01, 0x00, 0x05, 0x01, 0x00, 0xf3, 0xcf, 0x03, 0x00, 0x00, 0x00,
    };

//    front->orders->init();
////    assert(sizeof(compressed_i0_j0) == 635);
//    printf("compression_type = %d\n", front->bmp_cache->compressed_cache_type);
//    switch (front->bmp_cache->compressed_cache_type){
//        case 2:
//            front->orders->send_bitmap_small_headers(
//                64, 64, front->colors.bpp, compressed_i0_j0, sizeof(compressed_i0_j0), 2, 98);
//            break;
//        case 1:
//            front->orders->send_bitmap(
//                64, 64, front->colors.bpp, compressed_i0_j0, sizeof(compressed_i0_j0), 2, 98);
//        break;
//        default:
//            assert(false);
//        break;
//    }
//    front->orders->mem_blt(2, 0, Rect(0, 0, 64, 64), 0xcc, 64, 64, 0, 0, 98, Rect(0, 0, 800, 600));
//    front->orders->send();

    front->orders->init();
//    assert(sizeof(compressed_i0_j0) == 635);
    printf("compression_type = %d\n", front->bmp_cache->compressed_cache_type);
    switch (front->bmp_cache->compressed_cache_type){
        case 2:
            front->orders->send_bitmap_small_headers(
                64, 64, front->colors.bpp, compressed_i64_j0, sizeof(compressed_i64_j0), 2, 98);
            break;
        case 1:
            front->orders->send_bitmap(
                64, 64, front->colors.bpp, compressed_i64_j0, sizeof(compressed_i64_j0), 2, 98);
        break;
        default:
            assert(false);
        break;
    }
    front->orders->mem_blt(2, 0, Rect(65, 0, 64, 64), 0xcc, 64, 64, 0, 0, 98, Rect(0, 0, 800, 600));
    front->orders->send();


//orders::send_bitmap_small_headers width=64 height=64 bpp=24 data=0xbfcad96c bufsize=635 2:129
////mem_blt(color_table=0, r(0, 0, 64, 64), rop=cc, bmp_cx=64, bmp_cy=64, srcx=0, srcy=0, clip(0, 0, 800, 600) cache 2:129

//    {
//        LOG(LOG_INFO, "logo size: %d %d", logobmp2.cx, logobmp2.cy);

//        front->begin_update();
//        front->send_bitmap_front(
//        Rect(0, 0, logobmp2.cx, logobmp2.cy),
//        // src_r(0, 0, 256, 125)
//        Rect(0, 0, logobmp2.cx, logobmp2.cy),
//           (uint8_t*)logobmp2.data_co,
//           colors, 0, Rect(0, 0, logobmp2.cx, logobmp2.cy));
//        front->end_update();
//    }

    cout << "waiting for 50 seconds\n";
    sleep(50);
    return STATE_STOP;
}

t_internal_state step_STATE_ENTRY(struct timeval & time, wait_obj & evt, int sck, Front * front)
{

    cout << "STATE ENTRY\n";

    unsigned max = 0;
    fd_set rfds;
    fd_set wfds;

    FD_ZERO(&rfds);
    FD_ZERO(&wfds);

    evt.add_to_fd_set(rfds, max);

    int i = select(max + 1, &rfds, &wfds, 0, &time);
    if (((i < 0)
            && (errno != EAGAIN)
            && (errno != EWOULDBLOCK)
            && (errno != EINPROGRESS)
            && (errno != EINTR)))
    {
        return STATE_STOP;
    }

    Stream s(8192);
    if (evt.is_set()) {
        try {
            LOG(LOG_DEBUG, "waiting for up_and_runing\n");
            front->orders->rdp_layer->activate_and_process_data(s);
            LOG(LOG_DEBUG, "now up_and_running\n");

        front->reset(front->orders, front->cache, front->font);

        LOG(LOG_INFO, "width=%d height=%d bpp=%d "
                  "cache1_entries=%d cache1_size=%d "
                  "cache2_entries=%d cache2_size=%d "
                  "cache2_entries=%d cache2_size=%d ",
        front->orders->rdp_layer->client_info.width,
        front->orders->rdp_layer->client_info.height,
        front->orders->rdp_layer->client_info.bpp,
        front->orders->rdp_layer->client_info.cache1_entries,
        front->orders->rdp_layer->client_info.cache1_size,
        front->orders->rdp_layer->client_info.cache2_entries,
        front->orders->rdp_layer->client_info.cache2_size,
        front->orders->rdp_layer->client_info.cache3_entries,
        front->orders->rdp_layer->client_info.cache3_size);

            return STATE_RUNNING;
        }
        catch (Error e){
            cout << "catched exception " << e.id << "\n";
            exit(0);
        }
        catch(...){
            cout << "catched exception\n";
            return STATE_STOP;
        };
    }
    return STATE_ENTRY;
}


int hook(int sck)
{
    openlog("rdpproxy", LOG_CONS | LOG_PERROR, LOG_USER);

        /* set non blocking */
    int rv = fcntl(sck, F_SETFL, fcntl(sck, F_GETFL) | O_NONBLOCK);
    if (rv < 0){
        /* 1 session_main_loop fnctl socket error */
        throw 1;
    }
    int nodelay = 1;

    /* SOL_TCP IPPROTO_TCP */
    setsockopt(sck, IPPROTO_TCP, TCP_NODELAY, (char*)&nodelay, sizeof(nodelay));
    if (rv < 0){
        /* 2 session_main_loop fnctl socket error */
        throw 2;
    }

    wait_obj client_event(sck);

   struct VoidCallback : public Callback
    {
        Front * front;
        VoidCallback(){}

        virtual int callback(int msg, long param1, long param2, long param3, long param4)
        {
            return 0;
        }
    } void_callback;

    try {

        Inifile ini(CFG_PATH "/rdpproxy.ini");
        SocketTransport * trans = new SocketTransport(sck, NULL);
        server_rdp * server = new server_rdp(void_callback, trans, &ini);
        RDP::Orders * orders = new RDP::Orders(server);
        ClientInfo * client_info = &(server->client_info);
        Font * default_font = new Font(SHARE_PATH "/" DEFAULT_FONT_NAME);
        Cache * cache = new Cache(orders, client_info);
        Colors colors(16);
        RGBPalette palette;
        colors.get_palette(palette);
        int timezone = -3600;
        Front * front = new Front(orders, cache, default_font, colors, palette, false, false, timezone);
        void_callback.front = front;

        Rsakeys * rsa_keys = new Rsakeys(CFG_PATH "/rsakeys.ini");

        t_internal_state internal_state = STATE_RSA_KEY_HANDSHAKE;

        cout << "Entering main loop\n";

        bool loop_flag = true;
        while (loop_flag) {
            int timeout = 50;
            static struct timeval time = { 0, 0};
            if (time.tv_sec == 0 && time.tv_usec < 100){
                time.tv_sec = timeout / 100000;
                time.tv_usec = (timeout % 1000) * 1000;
                // about one snapshot each second
            }
            switch (internal_state)
            {
                case STATE_RSA_KEY_HANDSHAKE:
                    cout << "handshaking\n";
                    server->server_rdp_incoming(rsa_keys);
                    internal_state = STATE_ENTRY;
                break;
                case STATE_ENTRY:
                    cout << "state entry\n";
                    internal_state = step_STATE_ENTRY(time, client_event, sck, front);
                break;
                case STATE_RUNNING:
                    cout << "state running\n";
                    internal_state = step_STATE_RUNNING(
                                                    time,
                                                    sck,
                                                    orders,
                                                    cache,
                                                    default_font,
                                                    client_info,
                                                    front);
                break;
                default:
                    loop_flag = false;
                break;
            }
        }
    } catch (...) {
        cout << "Exception catched End of test server\n";
    };

    sleep(10);
    cout << "out of hook\n";

    return 0;
}


int main()
{
    int sck = socket(AF_INET, SOCK_STREAM, 0);

    // reuse same port if a previous daemon was stopped
    int allow_reuse = 1;
    setsockopt(sck, SOL_SOCKET, SO_REUSEADDR, (char*)&allow_reuse, sizeof(allow_reuse));

    int port = 3392;
    const char *ip = "0.0.0.0";

    struct sockaddr_in saddr;

    memset(&saddr, 0, sizeof(struct sockaddr_in));
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(port);
    saddr.sin_addr.s_addr = inet_addr(ip);
    bind(sck, (struct sockaddr*)&saddr, sizeof(struct sockaddr_in));
    listen(sck, 2);

    struct pollfd fds[1];
    printf("Running server\n");
    for (;;)
    {
        fds[0].fd = sck;
        fds[0].events = POLLIN;
        fds[0].revents = 0;
        switch(poll(fds, 1, 1000000)){
            case 0:
                printf("No event occured in 1000s, looping\n");
            break;
            // error
            case -1:
                switch(errno){
                    // An invalid file descriptor was given in one of the sets.
                    case EBADF:
                        printf("EBADF error\n");
                    break;
                    // The array given as argument was not contained in the
                    // calling program's address space.
                    case EFAULT:
                        printf("EFAULT error\n");
                    break;

                    // A signal occurred before any requested event; see signal(7).
                    case EINTR:
                        printf("EINTR error\n");
                    break;

                    // The nfds value exceeds the RLIMIT_NOFILE value.
                    case EINVAL:
                        printf("EINVAL error\n");
                    break;

                    // There was no space to allocate file descriptor tables.
                    case ENOMEM:
                        printf("ENOMEM error\n");
                    break;
                }
                exit(-1);
            break;
            // normal behavior, a positive number of events occured
            default:
                struct sockaddr_in sin;
                unsigned int sin_size = sizeof(struct sockaddr_in);
                memset(&sin, 0, sin_size);
                int in_sck = accept(sck, (struct sockaddr*)&sin, &sin_size);
                if (!fork()){
                    exit(hook(in_sck));
                }
                close(in_sck);
            break;
        }
    }
    return 0;
}
