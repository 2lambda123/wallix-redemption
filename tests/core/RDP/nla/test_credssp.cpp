/*
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

  Product name: redemption, a FLOSS RDP proxy
  Copyright (C) Wallix 2013
  Author(s): Christophe Grosjean, Raphael Zhou, Meng Tan
*/

#include <ostream>
#include <vector>

#include "test_only/test_framework/redemption_unit_tests.hpp"


#include "core/RDP/nla/credssp.hpp"

#include "test_only/check_sig.hpp"


RED_AUTO_TEST_CASE(TestBERIntegerCase1)
{
    auto r = BER::mkInteger(114178754);
    RED_CHECK_EQUAL(r.size(), 6);

    InStream in_s(r);
    uint32_t value = BER::read_integer(in_s, "Integer", ERR_CREDSSP_TS_REQUEST);
    RED_CHECK_EQUAL(value, 114178754);
}

RED_AUTO_TEST_CASE(TestBERIntegerCase2)
{
    auto r = BER::mkInteger(1);
    RED_CHECK_EQUAL(r.size(), 3);

    InStream in_s = InStream(r);
    uint32_t value = BER::read_integer(in_s, "Integer", ERR_CREDSSP_TS_REQUEST);

    RED_CHECK_EQUAL(value, 1);
}

RED_AUTO_TEST_CASE(TestBERIntegerCase3)
{
    auto r = BER::mkInteger(52165);
    RED_CHECK_EQUAL(r.size(), 5);

    InStream in_s = InStream(r);
    uint32_t value = BER::read_integer(in_s, "Integer", ERR_CREDSSP_TS_REQUEST);

    RED_CHECK_EQUAL(value, 52165);
}

RED_AUTO_TEST_CASE(TestBERIntegerCase4)
{
    auto r = BER::mkInteger(0x0FFF);
    RED_CHECK_EQUAL(r.size(), 4);

    InStream in_s = InStream(r);
    uint32_t value = BER::read_integer(in_s, "Integer", ERR_CREDSSP_TS_REQUEST);

    RED_CHECK_EQUAL(value, 0x0FFF);
}

RED_AUTO_TEST_CASE(TestBEROctetString)
{
    StaticOutStream<2048> s;
    const uint8_t oct_str[] = {1, 2, 3, 4, 5, 6, 7};

    auto r = BER::mkOctetStringHeader(sizeof(oct_str));
    r.insert(r.end(), oct_str, oct_str+sizeof(oct_str));

    InStream in_s(r);
    int length = BER::read_tag_length(in_s, BER::CLASS_UNIV|BER::PC_PRIMITIVE|BER::TAG_OCTET_STRING, "TestOctetString", ERR_CREDSSP_TS_REQUEST);
    RED_CHECK_EQUAL(length, 7);
}


RED_AUTO_TEST_CASE(TestBERContextual)
{
    StaticOutStream<2048> s;
    uint8_t tag = 0x06;

    const uint8_t data[] = {0, 1, 2};

    auto v = BER::mkContextualFieldHeader(sizeof(data), tag);
    v.insert(v.end(), data, data+sizeof(data));

    InStream in_s(v);
    RED_CHECK_EQUAL(true, BER::check_ber_ctxt_tag(in_s, tag));
    in_s.in_skip_bytes(1);
    int length = BER::read_length(in_s, "TS Request [1] negoTokens", ERR_CREDSSP_TS_REQUEST);
    RED_CHECK_EQUAL(length, sizeof(data));
}

RED_AUTO_TEST_CASE(TestTSRequestNTLMSSP_NEGOTIATE)
{
    // ===== NTLMSSP_NEGOTIATE =====
    constexpr static uint8_t packet[] = {
        0x30, 0x37, 0xa0, 0x03, 0x02, 0x01, 0x03, 0xa1,
        0x30, 0x30, 0x2e, 0x30, 0x2c, 0xa0, 0x2a, 0x04,
        0x28, 0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50,
        0x00, 0x01, 0x00, 0x00, 0x00, 0xb7, 0x82, 0x08,
        0xe2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x05, 0x01, 0x28, 0x0a, 0x00, 0x00, 0x00,
        0x0f
    };

    TSRequest ts_req = recvTSRequest(make_array_view(packet), 3);

    RED_CHECK_EQUAL(ts_req.version, 3);
    RED_CHECK_EQUAL(ts_req.negoTokens.size(), 0x28);
    RED_CHECK_EQUAL(ts_req.authInfo.size(), 0);
    RED_CHECK_EQUAL(ts_req.error_code, 0);
    RED_CHECK_EQUAL(ts_req.pubKeyAuth.size(), 0);

    auto v = emitTSRequest(ts_req.version,
                           ts_req.negoTokens,
                           ts_req.authInfo,
                           ts_req.pubKeyAuth,
                           ts_req.error_code,
                           ts_req.clientNonce.clientNonce,
                           ts_req.clientNonce.initialized);
    RED_CHECK_EQUAL(v.size(), 0x37 + 2);
    RED_CHECK_SIG_FROM(v, packet);
}

RED_AUTO_TEST_CASE(TestTSRequestNTLMSSP_CHALLENGE)
{
// ===== NTLMSSP_CHALLENGE =====
    constexpr static uint8_t packet[] = {
        0x30, 0x81, 0x94, 0xa0, 0x03, 0x02, 0x01, 0x03,
        0xa1, 0x81, 0x8c, 0x30, 0x81, 0x89, 0x30, 0x81,
        0x86, 0xa0, 0x81, 0x83, 0x04, 0x81, 0x80, 0x4e,
        0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x38,
        0x00, 0x00, 0x00, 0x35, 0x82, 0x8a, 0xe2, 0x26,
        0x6e, 0xcd, 0x75, 0xaa, 0x41, 0xe7, 0x6f, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
        0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x06,
        0x01, 0xb0, 0x1d, 0x00, 0x00, 0x00, 0x0f, 0x57,
        0x00, 0x49, 0x00, 0x4e, 0x00, 0x37, 0x00, 0x02,
        0x00, 0x08, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e,
        0x00, 0x37, 0x00, 0x01, 0x00, 0x08, 0x00, 0x57,
        0x00, 0x49, 0x00, 0x4e, 0x00, 0x37, 0x00, 0x04,
        0x00, 0x08, 0x00, 0x77, 0x00, 0x69, 0x00, 0x6e,
        0x00, 0x37, 0x00, 0x03, 0x00, 0x08, 0x00, 0x77,
        0x00, 0x69, 0x00, 0x6e, 0x00, 0x37, 0x00, 0x07,
        0x00, 0x08, 0x00, 0xa9, 0x8d, 0x9b, 0x1a, 0x6c,
        0xb0, 0xcb, 0x01, 0x00, 0x00, 0x00, 0x00
    };

    TSRequest ts_req = recvTSRequest(make_array_view(packet), 3);

    RED_CHECK_EQUAL(ts_req.version, 3);
    RED_CHECK_EQUAL(ts_req.negoTokens.size(), 0x80);
    RED_CHECK_EQUAL(ts_req.authInfo.size(), 0);
    RED_CHECK_EQUAL(ts_req.pubKeyAuth.size(), 0);

    auto v = emitTSRequest(ts_req.version,
                           ts_req.negoTokens,
                           ts_req.authInfo,
                           ts_req.pubKeyAuth,
                           ts_req.error_code,
                           ts_req.clientNonce.clientNonce,
                           ts_req.clientNonce.initialized);
    RED_CHECK_EQUAL(v.size(), 0x94 + 3);
    RED_CHECK_SIG_FROM(v, packet);
}


RED_AUTO_TEST_CASE(TestTSRequestNTLMSSP_AUTH)
{
    // ===== NTLMSSP_AUTH =====
    constexpr static uint8_t packet[] = {
        0x30, 0x82, 0x02, 0x41, 0xa0, 0x03, 0x02, 0x01,
        0x03, 0xa1, 0x82, 0x01, 0x12, 0x30, 0x82, 0x01,
        0x0e, 0x30, 0x82, 0x01, 0x0a, 0xa0, 0x82, 0x01,
        0x06, 0x04, 0x82, 0x01, 0x02, 0x4e, 0x54, 0x4c,
        0x4d, 0x53, 0x53, 0x50, 0x00, 0x03, 0x00, 0x00,
        0x00, 0x18, 0x00, 0x18, 0x00, 0x6a, 0x00, 0x00,
        0x00, 0x70, 0x00, 0x70, 0x00, 0x82, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x08, 0x00, 0x48, 0x00, 0x00,
        0x00, 0x10, 0x00, 0x10, 0x00, 0x50, 0x00, 0x00,
        0x00, 0x0a, 0x00, 0x0a, 0x00, 0x60, 0x00, 0x00,
        0x00, 0x10, 0x00, 0x10, 0x00, 0xf2, 0x00, 0x00,
        0x00, 0x35, 0x82, 0x88, 0xe2, 0x05, 0x01, 0x28,
        0x0a, 0x00, 0x00, 0x00, 0x0f, 0x77, 0x00, 0x69,
        0x00, 0x6e, 0x00, 0x37, 0x00, 0x75, 0x00, 0x73,
        0x00, 0x65, 0x00, 0x72, 0x00, 0x6e, 0x00, 0x61,
        0x00, 0x6d, 0x00, 0x65, 0x00, 0x57, 0x00, 0x49,
        0x00, 0x4e, 0x00, 0x58, 0x00, 0x50, 0x00, 0xa0,
        0x98, 0x01, 0x10, 0x19, 0xbb, 0x5d, 0x00, 0xf6,
        0xbe, 0x00, 0x33, 0x90, 0x20, 0x34, 0xb3, 0x47,
        0xa2, 0xe5, 0xcf, 0x27, 0xf7, 0x3c, 0x43, 0x01,
        0x4a, 0xd0, 0x8c, 0x24, 0xb4, 0x90, 0x74, 0x39,
        0x68, 0xe8, 0xbd, 0x0d, 0x2b, 0x70, 0x10, 0x01,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3,
        0x83, 0xa2, 0x1c, 0x6c, 0xb0, 0xcb, 0x01, 0x47,
        0xa2, 0xe5, 0xcf, 0x27, 0xf7, 0x3c, 0x43, 0x00,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x57,
        0x00, 0x49, 0x00, 0x4e, 0x00, 0x37, 0x00, 0x01,
        0x00, 0x08, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e,
        0x00, 0x37, 0x00, 0x04, 0x00, 0x08, 0x00, 0x77,
        0x00, 0x69, 0x00, 0x6e, 0x00, 0x37, 0x00, 0x03,
        0x00, 0x08, 0x00, 0x77, 0x00, 0x69, 0x00, 0x6e,
        0x00, 0x37, 0x00, 0x07, 0x00, 0x08, 0x00, 0xa9,
        0x8d, 0x9b, 0x1a, 0x6c, 0xb0, 0xcb, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb1,
        0xd2, 0x45, 0x42, 0x0f, 0x37, 0x9a, 0x0e, 0xe0,
        0xce, 0x77, 0x40, 0x10, 0x8a, 0xda, 0xba, 0xa3,
        0x82, 0x01, 0x22, 0x04, 0x82, 0x01, 0x1e, 0x01,
        0x00, 0x00, 0x00, 0x91, 0x5e, 0xb0, 0x6e, 0x72,
        0x82, 0x53, 0xae, 0x00, 0x00, 0x00, 0x00, 0x27,
        0x29, 0x73, 0xa9, 0xfa, 0x46, 0x17, 0x3c, 0x74,
        0x14, 0x45, 0x2a, 0xd1, 0xe2, 0x92, 0xa1, 0xc6,
        0x0a, 0x30, 0xd4, 0xcc, 0xe0, 0x92, 0xf6, 0xb3,
        0x20, 0xb3, 0xa0, 0xf1, 0x38, 0xb1, 0xf4, 0xe5,
        0x96, 0xdf, 0xa1, 0x65, 0x5b, 0xd6, 0x0c, 0x2a,
        0x86, 0x99, 0xcc, 0x72, 0x80, 0xbd, 0xe9, 0x19,
        0x1f, 0x42, 0x53, 0xf6, 0x84, 0xa3, 0xda, 0x0e,
        0xec, 0x10, 0x29, 0x15, 0x52, 0x5c, 0x77, 0x40,
        0xc8, 0x3d, 0x44, 0x01, 0x34, 0xb6, 0x0a, 0x75,
        0x33, 0xc0, 0x25, 0x71, 0xd3, 0x25, 0x38, 0x3b,
        0xfc, 0x3b, 0xa8, 0xcf, 0xba, 0x2b, 0xf6, 0x99,
        0x0e, 0x5f, 0x4e, 0xa9, 0x16, 0x2b, 0x52, 0x9f,
        0xbb, 0x76, 0xf8, 0x03, 0xfc, 0x11, 0x5e, 0x36,
        0x83, 0xd8, 0x4c, 0x9a, 0xdc, 0x9d, 0x35, 0xe2,
        0xc8, 0x63, 0xa9, 0x3d, 0x07, 0x97, 0x52, 0x64,
        0x54, 0x72, 0x9e, 0x9a, 0x8c, 0x56, 0x79, 0x4a,
        0x78, 0x91, 0x0a, 0x4c, 0x52, 0x84, 0x5a, 0x4a,
        0xb8, 0x28, 0x0b, 0x2f, 0xe6, 0x89, 0x7d, 0x07,
        0x3b, 0x7b, 0x6e, 0x22, 0xcc, 0x4c, 0xff, 0xf4,
        0x10, 0x96, 0xf2, 0x27, 0x29, 0xa0, 0x76, 0x0d,
        0x4c, 0x7e, 0x7a, 0x42, 0xe4, 0x1e, 0x6a, 0x95,
        0x7d, 0x4c, 0xaf, 0xdb, 0x86, 0x49, 0x5c, 0xbf,
        0xc2, 0x65, 0xb6, 0xf2, 0xed, 0xae, 0x8d, 0x57,
        0xed, 0xf0, 0xd4, 0xcb, 0x7a, 0xbb, 0x23, 0xde,
        0xe3, 0x43, 0xea, 0xb1, 0x02, 0xe3, 0xb4, 0x96,
        0xe9, 0xe7, 0x48, 0x69, 0xb0, 0xaa, 0xec, 0x89,
        0x38, 0x8b, 0xc2, 0xbd, 0xdd, 0xf7, 0xdf, 0xa1,
        0x37, 0xe7, 0x34, 0x72, 0x7f, 0x91, 0x10, 0x14,
        0x73, 0xfe, 0x32, 0xdc, 0xfe, 0x68, 0x2b, 0xc0,
        0x08, 0xdf, 0x05, 0xf7, 0xbd, 0x46, 0x33, 0xfb,
        0xc9, 0xfc, 0x89, 0xaa, 0x5d, 0x25, 0x49, 0xc8,
        0x6e, 0x86, 0xee, 0xc2, 0xce, 0xc4, 0x8e, 0x85,
        0x9f, 0xe8, 0x30, 0xb3, 0x86, 0x11, 0xd5, 0xb8,
        0x34, 0x4a, 0xe0, 0x03, 0xe5
    };

    TSRequest ts_req = recvTSRequest(make_array_view(packet), 3);

    RED_CHECK_EQUAL(ts_req.version, 3);
    RED_CHECK_EQUAL(ts_req.negoTokens.size(), 0x102);
    RED_CHECK_EQUAL(ts_req.authInfo.size(), 0);
    RED_CHECK_EQUAL(ts_req.pubKeyAuth.size(), 0x11e);

    auto v = emitTSRequest(ts_req.version,
                           ts_req.negoTokens,
                           ts_req.authInfo,
                           ts_req.pubKeyAuth,
                           ts_req.error_code,
                           ts_req.clientNonce.clientNonce,
                           ts_req.clientNonce.initialized);
    RED_CHECK_EQUAL(v.size(), 0x241 + 4);
    RED_CHECK_SIG_FROM(v, packet);
}

RED_AUTO_TEST_CASE(TestTSRequestPUBKEYAUTH)
{
// ===== PUBKEYAUTH =====
    constexpr static uint8_t packet[] = {
        0x30, 0x82, 0x01, 0x2b, 0xa0, 0x03, 0x02, 0x01,
        0x03, 0xa3, 0x82, 0x01, 0x22, 0x04, 0x82, 0x01,
        0x1e, 0x01, 0x00, 0x00, 0x00, 0xc9, 0x88, 0xfc,
        0xf1, 0x11, 0x68, 0x2c, 0x72, 0x00, 0x00, 0x00,
        0x00, 0xc7, 0x51, 0xf4, 0x71, 0xd3, 0x9f, 0xb6,
        0x50, 0xbe, 0xa8, 0xf6, 0x20, 0x77, 0xa1, 0xfc,
        0xdd, 0x8e, 0x02, 0xf0, 0xa4, 0x6b, 0xba, 0x3f,
        0x9d, 0x65, 0x9d, 0xab, 0x4a, 0x95, 0xc9, 0xb4,
        0x38, 0x03, 0x87, 0x04, 0xb1, 0xfe, 0x42, 0xec,
        0xfa, 0xfc, 0xaa, 0x85, 0xf1, 0x31, 0x2d, 0x26,
        0xcf, 0x63, 0xfd, 0x62, 0x36, 0xcf, 0x56, 0xc3,
        0xfb, 0xf6, 0x36, 0x9b, 0xe5, 0xb2, 0xe7, 0xce,
        0xcb, 0xe1, 0x82, 0xb2, 0x89, 0xff, 0xdd, 0x87,
        0x5e, 0xd3, 0xd8, 0xff, 0x2e, 0x16, 0x35, 0xad,
        0xdb, 0xda, 0xc9, 0xc5, 0x81, 0xad, 0x48, 0xf1,
        0x8b, 0x76, 0x3d, 0x74, 0x34, 0xdf, 0x80, 0x6b,
        0xf3, 0x68, 0x6d, 0xf6, 0xec, 0x5f, 0xbe, 0xea,
        0xb7, 0x6c, 0xea, 0xe4, 0xeb, 0xe9, 0x17, 0xf9,
        0x4e, 0x0d, 0x79, 0xd5, 0x82, 0xdd, 0xb7, 0xdc,
        0xcd, 0xfc, 0xbb, 0xf1, 0x0b, 0x9b, 0xe9, 0x18,
        0xe7, 0xb3, 0xb3, 0x8b, 0x40, 0x82, 0xa0, 0x9d,
        0x58, 0x73, 0xda, 0x54, 0xa2, 0x2b, 0xd2, 0xb6,
        0x41, 0x60, 0x8a, 0x64, 0xf2, 0xa2, 0x59, 0x64,
        0xcf, 0x27, 0x1a, 0xe6, 0xb5, 0x1a, 0x0e, 0x0e,
        0xe1, 0x14, 0xef, 0x26, 0x68, 0xeb, 0xc8, 0x49,
        0xe2, 0x66, 0xbb, 0x11, 0x71, 0x49, 0xad, 0x7e,
        0xae, 0xde, 0xa8, 0x78, 0xfd, 0x64, 0x51, 0xd8,
        0x18, 0x01, 0x11, 0xc0, 0x8d, 0x3b, 0xec, 0x40,
        0x2b, 0x1f, 0xc5, 0xa4, 0x45, 0x1e, 0x07, 0xae,
        0x5a, 0xd8, 0x1c, 0xab, 0xdf, 0x89, 0x96, 0xdc,
        0xdc, 0x29, 0xd8, 0x30, 0xdb, 0xbf, 0x48, 0x2a,
        0x42, 0x27, 0xc2, 0x50, 0xac, 0xf9, 0x02, 0xd1,
        0x20, 0x12, 0xdd, 0x50, 0x22, 0x09, 0x44, 0xac,
        0xe0, 0x22, 0x1f, 0x66, 0x64, 0xec, 0xfa, 0x2b,
        0xb8, 0xcd, 0x43, 0x3a, 0xce, 0x40, 0x74, 0xe1,
        0x34, 0x81, 0xe3, 0x94, 0x47, 0x6f, 0x49, 0x01,
        0xf8, 0xb5, 0xfc, 0xd0, 0x75, 0x80, 0xc6, 0x35,
        0xac, 0xc0, 0xfd, 0x1b, 0xb5, 0xa2, 0xd3
    };

    TSRequest ts_req = recvTSRequest(make_array_view(packet), 3);

    RED_CHECK_EQUAL(ts_req.version, 3);
    RED_CHECK_EQUAL(ts_req.negoTokens.size(), 0);
    RED_CHECK_EQUAL(ts_req.authInfo.size(), 0);
    RED_CHECK_EQUAL(ts_req.pubKeyAuth.size(), 0x11e);

    auto v = emitTSRequest(ts_req.version,
                           ts_req.negoTokens,
                           ts_req.authInfo,
                           ts_req.pubKeyAuth,
                           ts_req.error_code,
                           ts_req.clientNonce.clientNonce,
                           ts_req.clientNonce.initialized);
    RED_CHECK_EQUAL(v.size(), 0x12b + 4);
    RED_CHECK_SIG_FROM(v, packet);
}

RED_AUTO_TEST_CASE(TestTSRequestAUTHINFO)
{
    // ===== AUTHINFO =====
    constexpr static uint8_t packet[] = {
        0x30, 0x5a, 0xa0, 0x03, 0x02, 0x01, 0x03, 0xa2,
        0x53, 0x04, 0x51, 0x01, 0x00, 0x00, 0x00, 0xb3,
        0x2c, 0x3b, 0xa1, 0x36, 0xf6, 0x55, 0x71, 0x01,
        0x00, 0x00, 0x00, 0xa8, 0x85, 0x7d, 0x11, 0xef,
        0x92, 0xa0, 0xd6, 0xff, 0xee, 0xa1, 0xae, 0x6d,
        0xc5, 0x2e, 0x4e, 0x65, 0x50, 0x28, 0x93, 0x75,
        0x30, 0xe1, 0xc3, 0x37, 0xeb, 0xac, 0x1f, 0xdd,
        0xf3, 0xe0, 0x92, 0xf6, 0x21, 0xbc, 0x8f, 0xa8,
        0xd4, 0xe0, 0x5a, 0xa6, 0xff, 0xda, 0x09, 0x50,
        0x24, 0x0d, 0x8f, 0x8f, 0xf4, 0x92, 0xfe, 0x49,
        0x2a, 0x13, 0x52, 0xa6, 0x52, 0x75, 0x50, 0x8d,
        0x3e, 0xe9, 0x6b, 0x57
    };
    TSRequest ts_req = recvTSRequest(make_array_view(packet), 3);

    RED_CHECK_EQUAL(ts_req.version, 3);

    RED_CHECK_EQUAL(ts_req.negoTokens.size(), 0);
    RED_CHECK_EQUAL(ts_req.authInfo.size(), 0x51);
    RED_CHECK_EQUAL(ts_req.pubKeyAuth.size(), 0);

    auto v = emitTSRequest(ts_req.version,
                           ts_req.negoTokens,
                           ts_req.authInfo,
                           ts_req.pubKeyAuth,
                           ts_req.error_code,
                           ts_req.clientNonce.clientNonce,
                           ts_req.clientNonce.initialized);

    RED_CHECK_EQUAL(v.size(), 0x5c);
    RED_CHECK_SIG_FROM(v, packet);
}

RED_AUTO_TEST_CASE(TestTSCredentialsPassword)
{

    std::vector<uint8_t> domain = {'f', 'l', 'a', 't', 'l', 'a', 'n', 'd', 0};
    std::vector<uint8_t> user = { 's', 'q', 'u', 'a', 'r', 'e', 0};
    std::vector<uint8_t> pass = {'h', 'y', 'p', 'e', 'r', 'c', 'u', 'b', 'e', 0};

    auto r = emitTSCredentialsPassword(domain, user, pass);
    RED_CHECK_EQUAL(r.size(), r[1]+2);

    

    TSCredentials ts_cred_received = recvTSCredentials(r);

    RED_CHECK_EQUAL(ts_cred_received.credType, 1);
    RED_CHECK_EQUAL(ts_cred_received.passCreds.domainName, domain);
    RED_CHECK_EQUAL(ts_cred_received.passCreds.userName, user);
    RED_CHECK_EQUAL(ts_cred_received.passCreds.password, pass);


    std::vector<uint8_t> domain2 = {'s','o','m','e','w','h','e','r','e', 0};
    std::vector<uint8_t> user2 = {'s', 'o', 'm', 'e', 'o', 'n', 'e', 0};
    std::vector<uint8_t> pass2 = {'s', 'o', 'm', 'e', 'p', 'a', 's', 's', 0};
}

RED_AUTO_TEST_CASE(TestTSCredentialsSmartCard)
{

    std::vector<uint8_t> pin = {'3', '6', '1', '5', 0};
    std::vector<uint8_t> userHint = {'a', 'k', 'a', 0};
    std::vector<uint8_t> domainHint = {'g', 'r', 'a', 'n', 'd', 'p', 'a', 'r', 'c', 0};

    std::vector<uint8_t> cardName = {'p', 'a', 's', 's', 'e', 'p', 'a', 'r', 't', 'o', 'u', 't', 0};
    std::vector<uint8_t> readerName = {'a', 'c', 'r', 'o', 'b', 'a', 't', 0};
    std::vector<uint8_t> containerName = {'d', 'o', 'c', 'k', 'e', 'r', 0};
    std::vector<uint8_t> cspName = {'w', 'h', 'a', 't', 0};
    uint32_t keySpec = 32;

    auto r = emitTSCredentialsSmartCard(pin, userHint, domainHint, keySpec, cardName, readerName, containerName, cspName);
    RED_CHECK_EQUAL(r.size(), r[1]+2);

    TSCredentials ts_cred = recvTSCredentials(r);

    RED_CHECK_EQUAL(ts_cred.credType, 2);
    RED_CHECK_EQUAL(ts_cred.smartcardCreds.pin, pin);
    RED_CHECK_EQUAL(ts_cred.smartcardCreds.userHint, userHint);
    RED_CHECK_EQUAL(ts_cred.smartcardCreds.domainHint, domainHint);
    RED_CHECK_EQUAL(ts_cred.smartcardCreds.cspData.keySpec, keySpec);
    
    RED_CHECK_SMEM(ts_cred.smartcardCreds.cspData.cardName, cardName);
    RED_CHECK_SMEM(ts_cred.smartcardCreds.cspData.readerName, readerName);
    RED_CHECK_SMEM(ts_cred.smartcardCreds.cspData.containerName, containerName);
    RED_CHECK_SMEM(ts_cred.smartcardCreds.cspData.cspName, cspName);
}

//rdpCredssp - Client Authentication : Sending Authentication Token
//TSRequest hexdump ---------------------------------
//TSRequest version 6 ------------------------------
//TSRequest negoTokens ------------------------------
///* 0000 */ 0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x01, 0x00, 0x00, 0x00, 0xb7, 0x82, 0x08, 0xe2,  // NTLMSSP.........
///* 0010 */ 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,  // ....(.......(...
///* 0020 */ 0x06, 0x01, 0xb1, 0x1d, 0x00, 0x00, 0x00, 0x0f,                                                  // ........
//TSRequest authInfo --------------------------------
//TSRequest pubkeyAuth ------------------------------
//TSRequest error_code 0 ---------------------------
//TSRequest clientNonce -----------------------------
///* 0000 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ................
///* 0010 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ................
//TSRequest ts_request_header -----------------------
//TSRequest version_field ---------------------------
///* 0000 */ 0xa0, 0x03, 0x02, 0x01, 0x06,                                                                    // .....
//TSRequest nego_tokens_header ----------------------
///* 0000 */ 0xa1, 0x30, 0x30, 0x2e, 0x30, 0x2c, 0xa0, 0x2a, 0x04, 0x28,                                      // .00.0,.*.(
//TSRequest auth_info_header ------------------------
//TSRequest pub_key_auth_header ---------------------
//TSRequest error_code field ------------------------
//TSRequest nonce -----------------------------------
//emit TSRequest full dump--------------------------------
///* 0000 */ 0x30, 0x37, 0xa0, 0x03, 0x02, 0x01, 0x06, 0xa1, 0x30, 0x30, 0x2e, 0x30, 0x2c, 0xa0, 0x2a, 0x04,  // 07......00.0,.*.
///* 0010 */ 0x28, 0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x01, 0x00, 0x00, 0x00, 0xb7, 0x82, 0x08,  // (NTLMSSP........
///* 0020 */ 0xe2, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00,  // .....(.......(..
///* 0030 */ 0x00, 0x06, 0x01, 0xb1, 0x1d, 0x00, 0x00, 0x00, 0x0f,                                            // .........
//emit TSRequest hexdump -DONE----------------------------

RED_AUTO_TEST_CASE(TestNTLMMessagesNegotiate)
{
    std::vector<uint8_t> expectedNegoTokens = {
        0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x01, 0x00, 0x00, 0x00, 0xb7, 0x82, 0x08, 0xe2,  // NTLMSSP.........
        0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,  // ....(.......(...
        0x06, 0x01, 0xb1, 0x1d, 0x00, 0x00, 0x00, 0x0f,
    };
    auto negoTokens = emitNTLMNegotiateMessage();
    
    RED_CHECK_EQUAL(expectedNegoTokens, negoTokens);
}

RED_AUTO_TEST_CASE(TestNTLMMessagesChallenge)
{
    std::vector<uint8_t> negoTokens = {
         /* 0000 */ 0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00,  // NTLMSSP.........
         /* 0010 */ 0x38, 0x00, 0x00, 0x00, 0x35, 0x82, 0x89, 0xe2, 0x01, 0x05, 0x03, 0x5c, 0x69, 0x17, 0x57, 0x89,  // 8...5.......i.W.
         /* 0020 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa6, 0x00, 0xa6, 0x00, 0x48, 0x00, 0x00, 0x00,  // ............H...
         /* 0030 */ 0x06, 0x03, 0x80, 0x25, 0x00, 0x00, 0x00, 0x0f, 0x50, 0x00, 0x52, 0x00, 0x4f, 0x00, 0x58, 0x00,  // ...%....P.R.O.X.
         /* 0040 */ 0x59, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00, 0x02, 0x00, 0x10, 0x00, 0x50, 0x00, 0x52, 0x00,  // Y.K.D.C.....P.R.
         /* 0050 */ 0x4f, 0x00, 0x58, 0x00, 0x59, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00, 0x01, 0x00, 0x14, 0x00,  // O.X.Y.K.D.C.....
         /* 0060 */ 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00, 0x32, 0x00, 0x30, 0x00,  // W.I.N.K.D.C.2.0.
         /* 0070 */ 0x31, 0x00, 0x32, 0x00, 0x04, 0x00, 0x18, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00,  // 1.2.....p.r.o.x.
         /* 0080 */ 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00,  // y.k.d.c...l.a.b.
         /* 0090 */ 0x03, 0x00, 0x2e, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00,  // ....W.I.N.K.D.C.
         /* 00a0 */ 0x32, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x2e, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00,  // 2.0.1.2...p.r.o.
         /* 00b0 */ 0x78, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00,  // x.y.k.d.c...l.a.
         /* 00c0 */ 0x62, 0x00, 0x05, 0x00, 0x18, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00, 0x79, 0x00,  // b.....p.r.o.x.y.
         /* 00d0 */ 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00, 0x07, 0x00,  // k.d.c...l.a.b...
         /* 00e0 */ 0x08, 0x00, 0xe5, 0xda, 0xa6, 0x1d, 0x5c, 0x62, 0xd5, 0x01, 0x00, 0x00, 0x00, 0x00,              // .......b......
    };
    NTLMChallengeMessage challenge_message = recvNTLMChallengeMessage(negoTokens);

    RED_CHECK_EQUAL(challenge_message.raw_bytes, negoTokens);

    RED_CHECK_EQUAL(challenge_message.TargetName.bufferOffset, 56);
    RED_CHECK_EQUAL(challenge_message.TargetName.buffer, 
        std::vector<uint8_t>({
        /* 0000 */ 0x50, 0x00, 0x52, 0x00, 0x4f, 0x00, 0x58, 0x00, 0x59, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00,  // P.R.O.X.Y.K.D.C.
        })
    );

//    hexdump_d(challenge_message.serverChallenge);
    array_challenge expected_server_challenge{0x01, 0x05, 0x03, 0x5c, 0x69, 0x17, 0x57, 0x89};
    BOOST_CHECK(challenge_message.serverChallenge == expected_server_challenge);

    logNtlmFlags(challenge_message.negoFlags.flags);

    RED_CHECK(challenge_message.negoFlags.flags == 
            (NTLMSSP_NEGOTIATE_56|
            NTLMSSP_NEGOTIATE_KEY_EXCH|
            NTLMSSP_NEGOTIATE_128|
            NTLMSSP_NEGOTIATE_VERSION|
            NTLMSSP_NEGOTIATE_TARGET_INFO|
            NTLMSSP_NEGOTIATE_EXTENDED_SESSION_SECURITY|
            NTLMSSP_TARGET_TYPE_DOMAIN|
            NTLMSSP_NEGOTIATE_ALWAYS_SIGN|
            NTLMSSP_NEGOTIATE_NTLM|
            NTLMSSP_NEGOTIATE_SEAL|
            NTLMSSP_NEGOTIATE_SIGN|
            NTLMSSP_REQUEST_TARGET|
            NTLMSSP_NEGOTIATE_UNICODE)
    );

//    hexdump_d(challenge_message.TargetInfo.buffer);
    RED_CHECK_EQUAL(challenge_message.TargetInfo.bufferOffset, 72);
    RED_CHECK_EQUAL(challenge_message.TargetInfo.buffer, std::vector<uint8_t>({
 /* 0000 */ 0x02, 0x00, 0x10, 0x00, 0x50, 0x00, 0x52, 0x00, 0x4f, 0x00, 0x58, 0x00, 0x59, 0x00, 0x4b, 0x00,  // ....P.R.O.X.Y.K.
 /* 0010 */ 0x44, 0x00, 0x43, 0x00, 0x01, 0x00, 0x14, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x4b, 0x00,  // D.C.....W.I.N.K.
 /* 0020 */ 0x44, 0x00, 0x43, 0x00, 0x32, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x04, 0x00, 0x18, 0x00,  // D.C.2.0.1.2.....
 /* 0030 */ 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00,  // p.r.o.x.y.k.d.c.
 /* 0040 */ 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00, 0x03, 0x00, 0x2e, 0x00, 0x57, 0x00, 0x49, 0x00,  // ..l.a.b.....W.I.
 /* 0050 */ 0x4e, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00, 0x32, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00,  // N.K.D.C.2.0.1.2.
 /* 0060 */ 0x2e, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00,  // ..p.r.o.x.y.k.d.
 /* 0070 */ 0x63, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00, 0x05, 0x00, 0x18, 0x00, 0x70, 0x00,  // c...l.a.b.....p.
 /* 0080 */ 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e, 0x00,  // r.o.x.y.k.d.c...
 /* 0090 */ 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00, 0x07, 0x00, 0x08, 0x00, 0xe5, 0xda, 0xa6, 0x1d, 0x5c, 0x62,  // l.a.b..........b
 /* 00a0 */ 0xd5, 0x01, 0x00, 0x00, 0x00, 0x00,
    }));

    RED_CHECK_EQUAL(challenge_message.version.ProductMajorVersion, 6);
    RED_CHECK_EQUAL(challenge_message.version.ProductMinorVersion, 3);
    RED_CHECK_EQUAL(challenge_message.version.ProductBuild, 9600);
    RED_CHECK_EQUAL(challenge_message.version.NtlmRevisionCurrent, 15);

//    // Vector of AvPair
    RED_CHECK_EQUAL(challenge_message.AvPairList.size(), 6);
//    hexdump_d(challenge_message.AvPairList[0].data);
    // MsvAvNbDomainName    = 0x02,
    RED_CHECK_EQUAL(challenge_message.AvPairList[0].id, MsvAvNbDomainName);
    RED_CHECK_EQUAL(challenge_message.AvPairList[0].data, std::vector<uint8_t>({
        /* 0000 */ 0x50, 0x00, 0x52, 0x00, 0x4f, 0x00, 0x58, 0x00, 0x59, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00,  // P.R.O.X.Y.K.D.C.
    }));
//    hexdump_d(challenge_message.AvPairList[1].data);
    // MsvAvNbComputerName  = 0x01,
    RED_CHECK_EQUAL(challenge_message.AvPairList[1].id, MsvAvNbComputerName);
    RED_CHECK_EQUAL(challenge_message.AvPairList[1].data, std::vector<uint8_t>({
    /* 0000 */ 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00, 0x32, 0x00, 0x30, 0x00,  // W.I.N.K.D.C.2.0.
    /* 0010 */ 0x31, 0x00, 0x32, 0x00,                                                                          // 1.2.
    }));
//    hexdump_d(challenge_message.AvPairList[2].data);
    // MsvAvDnsDomainName   = 0x04,
    RED_CHECK_EQUAL(challenge_message.AvPairList[2].id, MsvAvDnsDomainName);
    RED_CHECK_EQUAL(challenge_message.AvPairList[2].data, std::vector<uint8_t>({
    /* 0000 */ 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00,  // p.r.o.x.y.k.d.c.
    /* 0010 */ 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00,                                                  // ..l.a.b.
    }));
//    hexdump_d(challenge_message.AvPairList[3].data);
    // MsvAvDnsComputerName = 0x03,
    RED_CHECK_EQUAL(challenge_message.AvPairList[3].id, MsvAvDnsComputerName);
    RED_CHECK_EQUAL(challenge_message.AvPairList[3].data, std::vector<uint8_t>({
    /* 0000 */ 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00, 0x32, 0x00, 0x30, 0x00,  // W.I.N.K.D.C.2.0.
    /* 0010 */ 0x31, 0x00, 0x32, 0x00, 0x2e, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00, 0x79, 0x00,  // 1.2...p.r.o.x.y.
    /* 0020 */ 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00,              // k.d.c...l.a.b.
    }));
//    hexdump_d(challenge_message.AvPairList[4].data);
    // MsvAvDnsTreeName     = 0x05,
    RED_CHECK_EQUAL(challenge_message.AvPairList[4].id, MsvAvDnsTreeName);
    RED_CHECK_EQUAL(challenge_message.AvPairList[4].data, std::vector<uint8_t>({
    /* 0000 */ 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00,  // p.r.o.x.y.k.d.c.
    /* 0010 */ 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00,                                                  // ..l.a.b.
    }));
//    hexdump_d(challenge_message.AvPairList[5].data);
    // MsvAvTimestamp       = 0x07,
    auto tt = challenge_message.AvPairList[5].data;
    uint64_t tstamp = (uint64_t(tt[7]) << 56) + (uint64_t(tt[6]) << 48) + (uint64_t(tt[5]) << 40) 
                    + (uint64_t(tt[4]) << 32) + (uint64_t(tt[3]) << 24) + (uint64_t(tt[2]) << 16)
                    + (uint64_t(tt[1]) << 8) + (uint64_t(tt[0]));
    RED_CHECK_EQUAL(challenge_message.AvPairList[5].id, MsvAvTimestamp);
    RED_CHECK_EQUAL(tstamp, 132119911851285221);
    RED_CHECK_EQUAL(challenge_message.AvPairList[5].data, std::vector<uint8_t>({
    /* 0000 */ 0xe5, 0xda, 0xa6, 0x1d, 0x5c, 0x62, 0xd5, 0x01,          
    }));
}


RED_AUTO_TEST_CASE(TestCredssp_scenarized_nla_ntlm)
{
    // negoTokens contains Negotiate Message
    {
        uint32_t version = 6;
        std::vector<uint8_t> negoTokens = {
            0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x01, 0x00, 0x00, 0x00, 0xb7, 0x82, 0x08, 0xe2,  // NTLMSSP.........
            0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,  // ....(.......(...
            0x06, 0x01, 0xb1, 0x1d, 0x00, 0x00, 0x00, 0x0f,
        };
        std::vector<uint8_t> authInfo = {};
        std::vector<uint8_t> pubKeyAuth = {};
        uint32_t error_code = 0;
        std::vector<uint8_t> clientNonce = {};

        auto result = emitTSRequest(version, negoTokens, authInfo, pubKeyAuth, error_code, clientNonce, false);

        std::vector<uint8_t> expectedResult = {
            // TSRequest ber sequence header
            0x30, 0x37, 
            // version field
            0xa0, 0x03, 0x02, 0x01, 0x06, 
            // negoTokens ber header
            0xa1, 0x30, 0x30, 0x2e, 0x30, 0x2c, 0xa0, 0x2a, 0x04, 0x28, // 07......00.0,.*.(
            // negoTokens
            0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x01, 0x00, 0x00, 0x00, 0xb7, 0x82, 0x08, 0xe2, // NTLMSSP........
            0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, // .....(.......(..
            0x06, 0x01, 0xb1, 0x1d, 0x00, 0x00, 0x00, 0x0f,  
        };

        RED_CHECK_EQUAL(expectedResult, result);
    }
    
    {
        std::vector<uint8_t> answerTSRequest = {
              0x30, 0x82, 0x01, 0x02, 0xa0, 0x03, 0x02, 0x01, 0x06, 0xa1, 0x81, 0xfa, 0x30, 0x81, 0xf7, 0x30 // 0...........0..0
            , 0x81, 0xf4, 0xa0, 0x81, 0xf1, 0x04, 0x81, 0xee, 0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00 // ........NTLMSSP.
            , 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x38, 0x00, 0x00, 0x00, 0x35, 0x82, 0x89, 0xe2 // ........8...5...
            , 0x01, 0x05, 0x03, 0x5c, 0x69, 0x17, 0x57, 0x89, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // ....i.W.........
            , 0xa6, 0x00, 0xa6, 0x00, 0x48, 0x00, 0x00, 0x00, 0x06, 0x03, 0x80, 0x25, 0x00, 0x00, 0x00, 0x0f // ....H......%....
            , 0x50, 0x00, 0x52, 0x00, 0x4f, 0x00, 0x58, 0x00, 0x59, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00 // P.R.O.X.Y.K.D.C.
            , 0x02, 0x00, 0x10, 0x00, 0x50, 0x00, 0x52, 0x00, 0x4f, 0x00, 0x58, 0x00, 0x59, 0x00, 0x4b, 0x00 // ....P.R.O.X.Y.K.
            , 0x44, 0x00, 0x43, 0x00, 0x01, 0x00, 0x14, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x4b, 0x00 // D.C.....W.I.N.K.
            , 0x44, 0x00, 0x43, 0x00, 0x32, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x04, 0x00, 0x18, 0x00 // D.C.2.0.1.2.....
            , 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00 // p.r.o.x.y.k.d.c.
            , 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00, 0x03, 0x00, 0x2e, 0x00, 0x57, 0x00, 0x49, 0x00 // ..l.a.b.....W.I.
            , 0x4e, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00, 0x32, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00 // N.K.D.C.2.0.1.2.
            , 0x2e, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00 // ..p.r.o.x.y.k.d.
            , 0x63, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00, 0x05, 0x00, 0x18, 0x00, 0x70, 0x00 // c...l.a.b.....p.
            , 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e, 0x00 // r.o.x.y.k.d.c...
            , 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00, 0x07, 0x00, 0x08, 0x00, 0xe5, 0xda, 0xa6, 0x1d, 0x5c, 0x62 // l.a.b..........b
            , 0xd5, 0x01, 0x00, 0x00, 0x00, 0x00                                                             // ......
        };


        //Client Authentication : Receiving Authentication Token
        // negoTokens contains Challenge Message
        auto ts_req = recvTSRequest(answerTSRequest);
        std::vector<uint8_t> expected_negoTokens = {
             /* 0000 */ 0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00,  // NTLMSSP.........
             /* 0010 */ 0x38, 0x00, 0x00, 0x00, 0x35, 0x82, 0x89, 0xe2, 0x01, 0x05, 0x03, 0x5c, 0x69, 0x17, 0x57, 0x89,  // 8...5.......i.W.
             /* 0020 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa6, 0x00, 0xa6, 0x00, 0x48, 0x00, 0x00, 0x00,  // ............H...
             /* 0030 */ 0x06, 0x03, 0x80, 0x25, 0x00, 0x00, 0x00, 0x0f, 0x50, 0x00, 0x52, 0x00, 0x4f, 0x00, 0x58, 0x00,  // ...%....P.R.O.X.
             /* 0040 */ 0x59, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00, 0x02, 0x00, 0x10, 0x00, 0x50, 0x00, 0x52, 0x00,  // Y.K.D.C.....P.R.
             /* 0050 */ 0x4f, 0x00, 0x58, 0x00, 0x59, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00, 0x01, 0x00, 0x14, 0x00,  // O.X.Y.K.D.C.....
             /* 0060 */ 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00, 0x32, 0x00, 0x30, 0x00,  // W.I.N.K.D.C.2.0.
             /* 0070 */ 0x31, 0x00, 0x32, 0x00, 0x04, 0x00, 0x18, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00,  // 1.2.....p.r.o.x.
             /* 0080 */ 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00,  // y.k.d.c...l.a.b.
             /* 0090 */ 0x03, 0x00, 0x2e, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00,  // ....W.I.N.K.D.C.
             /* 00a0 */ 0x32, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x2e, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00,  // 2.0.1.2...p.r.o.
             /* 00b0 */ 0x78, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00,  // x.y.k.d.c...l.a.
             /* 00c0 */ 0x62, 0x00, 0x05, 0x00, 0x18, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00, 0x79, 0x00,  // b.....p.r.o.x.y.
             /* 00d0 */ 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00, 0x07, 0x00,  // k.d.c...l.a.b...
             /* 00e0 */ 0x08, 0x00, 0xe5, 0xda, 0xa6, 0x1d, 0x5c, 0x62, 0xd5, 0x01, 0x00, 0x00, 0x00, 0x00,              // .......b......
        };
        std::vector<uint8_t> expected_authInfo = {};
        std::vector<uint8_t> expected_pubKeyAuth = {};
        std::vector<uint8_t> expected_clientNonce = {};

        RED_CHECK_EQUAL(6,                    ts_req.version);
        RED_CHECK_EQUAL(expected_negoTokens,ts_req.negoTokens);
        RED_CHECK_EQUAL(expected_authInfo,    ts_req.authInfo);
        RED_CHECK_EQUAL(expected_pubKeyAuth,  ts_req.pubKeyAuth);
        RED_CHECK_EQUAL(0,                    ts_req.error_code);
        RED_CHECK_EQUAL(expected_clientNonce, ts_req.clientNonce.clientNonce);
    }


    // Credssp contains NTLM Authenticate response message
    {
        uint32_t version = 6;
        std::vector<uint8_t> negoTokens = {                                                      0x4e, 0x54, 0x4c,  // .0...........NTL
        /* 0020 */ 0x4d, 0x53, 0x53, 0x50, 0x00, 0x03, 0x00, 0x00, 0x00, 0x18, 0x00, 0x18, 0x00, 0x58, 0x00, 0x00,  // MSSP.........X..
        /* 0030 */ 0x00, 0xd6, 0x00, 0xd6, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x01, 0x00,  // .....p.......F..
        /* 0040 */ 0x00, 0x34, 0x00, 0x34, 0x00, 0x46, 0x01, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x7a, 0x01, 0x00,  // .4.4.F.......z..
        /* 0050 */ 0x00, 0x10, 0x00, 0x10, 0x00, 0x86, 0x01, 0x00, 0x00, 0x35, 0xa2, 0x88, 0xe2, 0x06, 0x01, 0xb1,  // .........5......
        /* 0060 */ 0x1d, 0x00, 0x00, 0x00, 0x0f, 0x33, 0xf3, 0x6f, 0x74, 0xf6, 0xfd, 0xa4, 0x3f, 0x34, 0xef, 0x0a,  // .....3.ot...?4..
        /* 0070 */ 0x3e, 0xe3, 0x2c, 0x35, 0x1c, 0xac, 0xac, 0x50, 0x8b, 0x9e, 0x64, 0x06, 0xa2, 0x68, 0x8b, 0xf7,  // >.,5...P..d..h..
        /* 0080 */ 0xe5, 0x19, 0x9f, 0x6d, 0xe4, 0xff, 0x26, 0x7f, 0xac, 0x08, 0xe5, 0xc9, 0x19, 0x3c, 0x44, 0x18,  // ...m..&......<D.
        /* 0090 */ 0x87, 0xde, 0x60, 0x73, 0x3e, 0x0f, 0x50, 0x3b, 0xd9, 0x90, 0x75, 0x01, 0xd7, 0x01, 0x01, 0x00,  // ..`s>.P;..u.....
        /* 00a0 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0x6f, 0x0d, 0x00, 0x92, 0x6b, 0x6e, 0x5d, 0xff, 0x26, 0x7f,  // ......o...kn].&.
        /* 00b0 */ 0xac, 0x08, 0xe5, 0xc9, 0x19, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0x00, 0x50, 0x00, 0x52,  // .............P.R
        /* 00c0 */ 0x00, 0x4f, 0x00, 0x58, 0x00, 0x59, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00, 0x01, 0x00, 0x14,  // .O.X.Y.K.D.C....
        /* 00d0 */ 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00, 0x32, 0x00, 0x30,  // .W.I.N.K.D.C.2.0
        /* 00e0 */ 0x00, 0x31, 0x00, 0x32, 0x00, 0x04, 0x00, 0x18, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78,  // .1.2.....p.r.o.x
        /* 00f0 */ 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62,  // .y.k.d.c...l.a.b
        /* 0100 */ 0x00, 0x03, 0x00, 0x2e, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43,  // .....W.I.N.K.D.C
        /* 0110 */ 0x00, 0x32, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x2e, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6f,  // .2.0.1.2...p.r.o
        /* 0120 */ 0x00, 0x78, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x61,  // .x.y.k.d.c...l.a
        /* 0130 */ 0x00, 0x62, 0x00, 0x05, 0x00, 0x18, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00, 0x79,  // .b.....p.r.o.x.y
        /* 0140 */ 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00, 0x07,  // .k.d.c...l.a.b..
        /* 0150 */ 0x00, 0x08, 0x00, 0xe5, 0xda, 0xa6, 0x1d, 0x5c, 0x62, 0xd5, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,  // ........b.......
        /* 0160 */ 0x00, 0x00, 0x00, 0x41, 0x00, 0x64, 0x00, 0x6d, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x69, 0x00, 0x73,  // ...A.d.m.i.n.i.s
        /* 0170 */ 0x00, 0x74, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x40, 0x00, 0x70,  // .t.r.a.t.o.r.@.p
        /* 0180 */ 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e,  // .r.o.x.y.k.d.c..
        /* 0190 */ 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00, 0x63, 0x00, 0x67, 0x00, 0x72, 0x00, 0x74, 0x00, 0x68,  // .l.a.b.c.g.r.t.h
        /* 01a0 */ 0x00, 0x63, 0x00, 0x30, 0xbc, 0x1c, 0xba, 0x74, 0x8d, 0x07, 0x2f, 0x38, 0x82, 0x34, 0x5c, 0xbb,  // .c.0...t../8.4..
        /* 01b0 */ 0xf7, 0xa8, 0x39,
        };
        std::vector<uint8_t> authInfo = {};
        std::vector<uint8_t> pubKeyAuth = {
          0x01, 0x00, 0x00, 0x00, 0x40, 0x3a, 0x2a, 0xe6, 0xc6, 0xeb, 0x71, 0x91, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x35, 0x42, 0x55, 0x66, 0xe6, 0x54, 0x7a, 0x57, 0xa0, 0xa6, 0x06, 0xa9, 0xcf, 0xf1, 0x1e,
          0x36, 0xca, 0x53, 0xea, 0x91, 0x5a, 0xc1, 0x00, 0xf5, 0xf3, 0x4a, 0xdd, 0x87, 0x0c, 0x34, 0x00,
        };
        uint32_t error_code = 0;
        std::vector<uint8_t> clientNonce = {
            /* 0000 */ 0x08, 0x6f, 0xa9, 0xd9, 0xd9, 0xaf, 0x3f, 0xc0, 0x42, 0x41, 0x7e, 0x78, 0x70, 0x7e, 0x52, 0x20,  // .o....?.BA~xp~R 
            /* 0010 */ 0xd1, 0x94, 0x00, 0x96, 0x44, 0xd3, 0x2a, 0x59, 0xc2, 0x0d, 0x19, 0xf8, 0x7a, 0xbf, 0x36, 0xaf,  // ....D.*Y....z.6.
        };

        auto result = emitTSRequest(version, negoTokens, authInfo, pubKeyAuth, error_code, clientNonce, true);

        std::vector<uint8_t> expectedResult = {
        // ber TSRequest header
        /* 0000 */ 0x30, 0x82, 0x02, 0x07, 
        // ber version Field (version = 6)
                                           0xa0, 0x03, 0x02, 0x01, 0x06,
        // ber negoToken header
                                                                         0xa1, 0x82, 0x01, 0xa6, 0x30, 0x82, 0x01,  // 0............0..
        /* 0010 */ 0xa2, 0x30, 0x82, 0x01, 0x9e, 0xa0, 0x82, 0x01, 0x9a, 0x04, 0x82, 0x01, 0x96,
        // negoTokens data
                                                                                                 0x4e, 0x54, 0x4c,  // .0...........NTL
        /* 0020 */ 0x4d, 0x53, 0x53, 0x50, 0x00, 0x03, 0x00, 0x00, 0x00, 0x18, 0x00, 0x18, 0x00, 0x58, 0x00, 0x00,  // MSSP.........X..
        /* 0030 */ 0x00, 0xd6, 0x00, 0xd6, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x01, 0x00,  // .....p.......F..
        /* 0040 */ 0x00, 0x34, 0x00, 0x34, 0x00, 0x46, 0x01, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x7a, 0x01, 0x00,  // .4.4.F.......z..
        /* 0050 */ 0x00, 0x10, 0x00, 0x10, 0x00, 0x86, 0x01, 0x00, 0x00, 0x35, 0xa2, 0x88, 0xe2, 0x06, 0x01, 0xb1,  // .........5......
        /* 0060 */ 0x1d, 0x00, 0x00, 0x00, 0x0f, 0x33, 0xf3, 0x6f, 0x74, 0xf6, 0xfd, 0xa4, 0x3f, 0x34, 0xef, 0x0a,  // .....3.ot...?4..
        /* 0070 */ 0x3e, 0xe3, 0x2c, 0x35, 0x1c, 0xac, 0xac, 0x50, 0x8b, 0x9e, 0x64, 0x06, 0xa2, 0x68, 0x8b, 0xf7,  // >.,5...P..d..h..
        /* 0080 */ 0xe5, 0x19, 0x9f, 0x6d, 0xe4, 0xff, 0x26, 0x7f, 0xac, 0x08, 0xe5, 0xc9, 0x19, 0x3c, 0x44, 0x18,  // ...m..&......<D.
        /* 0090 */ 0x87, 0xde, 0x60, 0x73, 0x3e, 0x0f, 0x50, 0x3b, 0xd9, 0x90, 0x75, 0x01, 0xd7, 0x01, 0x01, 0x00,  // ..`s>.P;..u.....
        /* 00a0 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0x6f, 0x0d, 0x00, 0x92, 0x6b, 0x6e, 0x5d, 0xff, 0x26, 0x7f,  // ......o...kn].&.
        /* 00b0 */ 0xac, 0x08, 0xe5, 0xc9, 0x19, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0x00, 0x50, 0x00, 0x52,  // .............P.R
        /* 00c0 */ 0x00, 0x4f, 0x00, 0x58, 0x00, 0x59, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00, 0x01, 0x00, 0x14,  // .O.X.Y.K.D.C....
        /* 00d0 */ 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43, 0x00, 0x32, 0x00, 0x30,  // .W.I.N.K.D.C.2.0
        /* 00e0 */ 0x00, 0x31, 0x00, 0x32, 0x00, 0x04, 0x00, 0x18, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78,  // .1.2.....p.r.o.x
        /* 00f0 */ 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62,  // .y.k.d.c...l.a.b
        /* 0100 */ 0x00, 0x03, 0x00, 0x2e, 0x00, 0x57, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x4b, 0x00, 0x44, 0x00, 0x43,  // .....W.I.N.K.D.C
        /* 0110 */ 0x00, 0x32, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x2e, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6f,  // .2.0.1.2...p.r.o
        /* 0120 */ 0x00, 0x78, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x61,  // .x.y.k.d.c...l.a
        /* 0130 */ 0x00, 0x62, 0x00, 0x05, 0x00, 0x18, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00, 0x79,  // .b.....p.r.o.x.y
        /* 0140 */ 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00, 0x07,  // .k.d.c...l.a.b..
        /* 0150 */ 0x00, 0x08, 0x00, 0xe5, 0xda, 0xa6, 0x1d, 0x5c, 0x62, 0xd5, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,  // ........b.......
        /* 0160 */ 0x00, 0x00, 0x00, 0x41, 0x00, 0x64, 0x00, 0x6d, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x69, 0x00, 0x73,  // ...A.d.m.i.n.i.s
        /* 0170 */ 0x00, 0x74, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x40, 0x00, 0x70,  // .t.r.a.t.o.r.@.p
        /* 0180 */ 0x00, 0x72, 0x00, 0x6f, 0x00, 0x78, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x64, 0x00, 0x63, 0x00, 0x2e,  // .r.o.x.y.k.d.c..
        /* 0190 */ 0x00, 0x6c, 0x00, 0x61, 0x00, 0x62, 0x00, 0x63, 0x00, 0x67, 0x00, 0x72, 0x00, 0x74, 0x00, 0x68,  // .l.a.b.c.g.r.t.h
        /* 01a0 */ 0x00, 0x63, 0x00, 0x30, 0xbc, 0x1c, 0xba, 0x74, 0x8d, 0x07, 0x2f, 0x38, 0x82, 0x34, 0x5c, 0xbb,  // .c.0...t../8.4..
        /* 01b0 */ 0xf7, 0xa8, 0x39, 

        // optional authInfo field empty
        // ber pubkeyAuth header
                                     0xa3, 0x32, 0x04, 0x30,
        // pukeyAuth data
                                                             0x01, 0x00, 0x00, 0x00, 0x40, 0x3a, 0x2a, 0xe6, 0xc6,  // ..9.2.0....@:*..
        /* 01c0 */ 0xeb, 0x71, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x42, 0x55, 0x66, 0xe6, 0x54, 0x7a, 0x57,  // .q......5BUf.TzW
        /* 01d0 */ 0xa0, 0xa6, 0x06, 0xa9, 0xcf, 0xf1, 0x1e, 0x36, 0xca, 0x53, 0xea, 0x91, 0x5a, 0xc1, 0x00, 0xf5,  // .......6.S..Z...
        /* 01e0 */ 0xf3, 0x4a, 0xdd, 0x87, 0x0c, 0x34, 0x00,

        // error_code field empty (value is 0)
        // ber Nonce header
                                                             0xa5, 0x22, 0x04, 0x20, 
        // clientNonce data
                                                                                     0x08, 0x6f, 0xa9, 0xd9, 0xd9,  // .J...4..". .o...
        /* 01f0 */ 0xaf, 0x3f, 0xc0, 0x42, 0x41, 0x7e, 0x78, 0x70, 0x7e, 0x52, 0x20, 0xd1, 0x94, 0x00, 0x96, 0x44,  // .?.BA~xp~R ....D
        /* 0200 */ 0xd3, 0x2a, 0x59, 0xc2, 0x0d, 0x19, 0xf8, 0x7a, 0xbf, 0x36, 0xaf,                                // .*Y....z.6.
        };

        //TSRequest nonce -----------------------------------
        ///* 0000 */ 0xa5, 0x22, 0x04, 0x20,                                                                          // .". 

        RED_CHECK_EQUAL(expectedResult, result);
    }
    
    
    {
        // Client Authentication : Receiving Encrypted PubKey + 1
        std::vector<uint8_t> answerTSRequest = {
        // ber TSRequest header
        0x30, 0x39, 
        // ber Field version Integer 6
        0xa0, 0x03, 0x02, 0x01, 0x06,
        // ber pubKeyAuth header
        0xa3, 0x32, 0x04, 0x30,
        // pubKeyAuth
        0x01, 0x00, 0x00, 0x00, 0x13, 0x36, 0x33, 0x44, 0x80, 0xf7, 0xe5, 0xe1, 0x00, 0x00, 0x00, 0x00,
        0x5b, 0x1d, 0xb6, 0xba, 0xc8, 0xdb, 0xda, 0xc5, 0xb6, 0xca, 0xfe, 0x3b, 0x80, 0x51, 0x09, 0x7c,
        0x3e, 0xc7, 0xa6, 0x52, 0xa7, 0x6a, 0xa4, 0xf6, 0x56, 0xb9, 0x45, 0x1c, 0x62, 0xdc, 0x8a, 0x80
        };

        //Client Authentication : Receiving Authentication Token
        // negoTokens contains Challenge Message
        auto ts_req = recvTSRequest(answerTSRequest);
        std::vector<uint8_t> expected_negoTokens = {};
        std::vector<uint8_t> expected_authInfo = {};
        std::vector<uint8_t> expected_pubKeyAuth = {
        /* 0000 */ 0x01, 0x00, 0x00, 0x00, 0x13, 0x36, 0x33, 0x44, 0x80, 0xf7, 0xe5, 0xe1, 0x00, 0x00, 0x00, 0x00,  // .....63D........
        /* 0010 */ 0x5b, 0x1d, 0xb6, 0xba, 0xc8, 0xdb, 0xda, 0xc5, 0xb6, 0xca, 0xfe, 0x3b, 0x80, 0x51, 0x09, 0x7c,  // [..........;.Q.|
        /* 0020 */ 0x3e, 0xc7, 0xa6, 0x52, 0xa7, 0x6a, 0xa4, 0xf6, 0x56, 0xb9, 0x45, 0x1c, 0x62, 0xdc, 0x8a, 0x80,  // >..R.j..V.E.b...

        };
        std::vector<uint8_t> expected_clientNonce = {};

        hexdump_d(ts_req.pubKeyAuth);

        RED_CHECK_EQUAL(6,                    ts_req.version);
        RED_CHECK_EQUAL(expected_negoTokens,ts_req.negoTokens);
        RED_CHECK_EQUAL(expected_authInfo,    ts_req.authInfo);
        RED_CHECK_EQUAL(expected_pubKeyAuth,  ts_req.pubKeyAuth);
        RED_CHECK_EQUAL(0,                    ts_req.error_code);
        RED_CHECK_EQUAL(expected_clientNonce, ts_req.clientNonce.clientNonce);
    }

    {
        uint32_t version = 6;
        std::vector<uint8_t> negoTokens = {};
        std::vector<uint8_t> authInfo = {
        /* 0000 */ 0x01, 0x00, 0x00, 0x00, 0xe2, 0x09, 0x80, 0x28, 0x76, 0x33, 0x2d, 0xcc, 0x01, 0x00, 0x00, 0x00,  // .......(v3-.....
        /* 0010 */ 0x14, 0x67, 0x1b, 0x2f, 0x5e, 0x91, 0xde, 0x30, 0x48, 0x01, 0xe8, 0x47, 0xee, 0x75, 0xbc, 0xe2,  // .g./^..0H..G.u..
        /* 0020 */ 0xd7, 0x93, 0xc7, 0xe5, 0x63, 0x55, 0x86, 0x16, 0x61, 0xa1, 0x17, 0xe2, 0x6b, 0x75, 0x90, 0xe9,  // ....cU..a...ku..
        /* 0030 */ 0xc8, 0x59, 0xb3, 0x8f, 0x28, 0xfe, 0x3b, 0x8b, 0xbf, 0x29, 0x75, 0x69, 0x0a, 0x1b, 0xb1, 0x0a,  // .Y..(.;..)ui....
        /* 0040 */ 0x95, 0xae, 0x02, 0x75, 0x37, 0x58, 0x0b, 0x8a, 0xa1, 0xb2, 0x1d, 0xe3, 0x37, 0xfd, 0x58, 0x26,  // ...u7X......7.X&
        /* 0050 */ 0x4b, 0xa4, 0x34, 0xf5, 0x7a, 0x96, 0x9e, 0x49, 0xe4, 0x47, 0xfb, 0xdf, 0xcc, 0x62, 0x2b, 0x3b,  // K.4.z..I.G...b+;
        /* 0060 */ 0x6b, 0xe7, 0xfb, 0x0b, 0x3f, 0x4f, 0x0a, 0x97, 0x3b, 0xcd, 0x47, 0xef, 0x69, 0xd6, 0x35, 0xa7,  // k...?O..;.G.i.5.
        /* 0070 */ 0x7c, 0xd0, 0x5f, 0x95, 0x11, 0xa6, 0xe0,                                                        // |._....
        };
        std::vector<uint8_t> pubKeyAuth = {
        };
        uint32_t error_code = 0;
        std::vector<uint8_t> clientNonce = {
            /* 0000 */ 0x08, 0x6f, 0xa9, 0xd9, 0xd9, 0xaf, 0x3f, 0xc0, 0x42, 0x41, 0x7e, 0x78, 0x70, 0x7e, 0x52, 0x20,  // .o....?.BA~xp~R 
            /* 0010 */ 0xd1, 0x94, 0x00, 0x96, 0x44, 0xd3, 0x2a, 0x59, 0xc2, 0x0d, 0x19, 0xf8, 0x7a, 0xbf, 0x36, 0xaf,  // ....D.*Y....z.6.
        };

        auto result = emitTSRequest(version, negoTokens, authInfo, pubKeyAuth, error_code, clientNonce, true);

        std::vector<uint8_t> expectedResult = {
        // ber TSRequest header
        /* 0000 */ 0x30, 0x81, 0xa4, 
        // ber version Field (version 6)
                                     0xa0, 0x03, 0x02, 0x01, 0x06, 
        
        // authInfo ber header
                                                                   0xa2, 0x79, 0x04, 0x77, 
        // authInfo data
                                                                                           0x01, 0x00, 0x00, 0x00,  // 0........y.w....
        /* 0010 */ 0xe2, 0x09, 0x80, 0x28, 0x76, 0x33, 0x2d, 0xcc, 0x01, 0x00, 0x00, 0x00, 0x14, 0x67, 0x1b, 0x2f,  // ...(v3-......g./
        /* 0020 */ 0x5e, 0x91, 0xde, 0x30, 0x48, 0x01, 0xe8, 0x47, 0xee, 0x75, 0xbc, 0xe2, 0xd7, 0x93, 0xc7, 0xe5,  // ^..0H..G.u......
        /* 0030 */ 0x63, 0x55, 0x86, 0x16, 0x61, 0xa1, 0x17, 0xe2, 0x6b, 0x75, 0x90, 0xe9, 0xc8, 0x59, 0xb3, 0x8f,  // cU..a...ku...Y..
        /* 0040 */ 0x28, 0xfe, 0x3b, 0x8b, 0xbf, 0x29, 0x75, 0x69, 0x0a, 0x1b, 0xb1, 0x0a, 0x95, 0xae, 0x02, 0x75,  // (.;..)ui.......u
        /* 0050 */ 0x37, 0x58, 0x0b, 0x8a, 0xa1, 0xb2, 0x1d, 0xe3, 0x37, 0xfd, 0x58, 0x26, 0x4b, 0xa4, 0x34, 0xf5,  // 7X......7.X&K.4.
        /* 0060 */ 0x7a, 0x96, 0x9e, 0x49, 0xe4, 0x47, 0xfb, 0xdf, 0xcc, 0x62, 0x2b, 0x3b, 0x6b, 0xe7, 0xfb, 0x0b,  // z..I.G...b+;k...
        /* 0070 */ 0x3f, 0x4f, 0x0a, 0x97, 0x3b, 0xcd, 0x47, 0xef, 0x69, 0xd6, 0x35, 0xa7, 0x7c, 0xd0, 0x5f, 0x95,  // ?O..;.G.i.5.|._.
        /* 0080 */ 0x11, 0xa6, 0xe0,
        // Nonce ber header
                                     0xa5, 0x22, 0x04, 0x20,
        // client Nonce Data 
                                                             0x08, 0x6f, 0xa9, 0xd9, 0xd9, 0xaf, 0x3f, 0xc0, 0x42,  // ....". .o....?.B
        /* 0090 */ 0x41, 0x7e, 0x78, 0x70, 0x7e, 0x52, 0x20, 0xd1, 0x94, 0x00, 0x96, 0x44, 0xd3, 0x2a, 0x59, 0xc2,  // A~xp~R ....D.*Y.
        /* 00a0 */ 0x0d, 0x19, 0xf8, 0x7a, 0xbf, 0x36, 0xaf,                                                        // ...z.6.

        };

        RED_CHECK_EQUAL(expectedResult, result);
    }
}

