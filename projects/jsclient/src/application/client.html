<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>

body {
    display: flex;
}
form {
    margin-bottom: 2em
}

#login {
    background: orange
}

#clip {
    background: cyan
}

#canvasFocus {
    width: 0px;
    height: 0px;
    position: relative;
    z-index: -10;
    top: -800px;
}
#cbDownload {
    display: hidden
}
#login > fieldset {
    padding-bottom: 0;
}
#login, fieldset {
    column-count: auto;
}
#login label {
    display: inline-block
}

#clipForms form {
    padding: 0;
    margin: 0;
    display: inline-block
}

#login, #clipForms {
    margin:0;
    padding: 0px 5px 0px 5px;
}

    </style>
</head>
<body>

<div>
    <canvas id="canvas" width="800" height="600"></canvas>
    <input id="canvasFocus" type="text"/>
</div>
<section>
    <form id="login" method="get" action="#">
        <fieldset>
            <legend>Identification</legend>
            <label for="url">url: <input type="url" id="url" name="url" value="ws://localhost:3390" placeholder="websocket"/></label>
            <label for="user">User: <input type="text" id="user" name="user" value="x" placeholder="Username"/></label>
            <label for="pass">Pass: <input type="text" id="pass" name="pass" value="x" placeholder="Password"/></label>
        </fieldset>
        <fieldset>
            <legend>Graphics</legend>
            <label for="width">width: <input type="number" id="width" name="width" value="800" placeholder="Width"/></label>
            <label for="height">height: <input type="number" id="height" name="height" value="600" placeholder="Height"/></label>
            <label for="bpp">bpp: <select name="bpp" id="bpp">
                <option value="8">8</option>
                <option value="15">15</option>
                <option value="16" selected="selected">16</option>
                <option value="24">24</option>
                <option value="32">32</option>
            </select></label>
            <label for="disabledGraphics">disabled: <select name="disabledGraphics" id="disabledGraphics" multiple>
            </select></label>
            <label for="gdimpl">Impl: <select name="gdimpl" id="gdimpl">
                <option value="2d" selected="selected">Canvas 2d</option>
                <option value="webgl">WebGL</option>
                <option value="webgl2">WebGL2</option>
            </select>
        </fieldset>
        <fieldset>
            <legend>Others</legend>
            <label for="verbose">verbose: <input type="text" id="verbose" name="verbose" placeholder="Verbose"/></label>
            <label for="jsonConfig">JSON config: <textarea id="jsonConfig"></textarea></label>
            <label for="kbtype">Keyboard type: <select name="kbtype" id="kbtype">
                <option value="unicode">Unicode (KeyboardEvent.key)</option>
                <option value="scancode" selected="selected">Scancode (KeyboardEvent.code)</option>
                <option value="unicodeToScancode">UnicodeToScancode (KeyboardEvent.key)</option>
            </select>
        </fieldset>
        <p>
            <input type="submit" value="New Connection"/>
            <button id="disconnect" type="button" disabled="disabled">Disconnect</button>
            <a id="permalink" href="#">Permalink</a>
        </p>
    </form>

    <div id="clip">
        <div id="clipForms">
            <form id="sendCbFile" method="get" action="#">
                <fieldset>
                    <legend>File Clipboard</legend>
                    <input id="sendCbFile_data" name="myFile" type="file"/>
                    <input type="submit" value="Send File"/>
                </fieldset>
            </form>

            <form id="sendCbUtf8" method="get" action="#">
                <fieldset>
                    <legend>Text Clipboard</legend>
                    <textarea id="sendCbUtf8_data"></textarea>
                    <input type="submit" value="Send Text"/>
                </fieldset>
            </form>
        </div>

        <hr/>

        <div>
            <!-- <form id="receiveCbUtf8" method="get" action="#"> -->
                <!-- <input type="submit" value="Send Clipboard"> -->
                <textarea id="receiveCbUtf8_data"></textarea>
            <!-- </form> -->
            <p id="cbFmts"></p>
            <p id="cbFiles"></p>
            <a id="cbDownload"></a>
        </div>
    </div>

<section>

<script src="js_client.js"></script>
<script src="to_scancode.js"></script>
<script src="reverse_scancode.js"></script>
<script src="rdp_graphics.js"></script>
<script src="out_stream.js"></script>
<script src="clipboard.js"></script>

<script>
// new canvas whether new gdimpl
let ecanvas = document.getElementById('canvas');
const ecanvasFocus = document.getElementById('canvasFocus');
const login = document.getElementById('login');
const disconnectButton = document.getElementById('disconnect');
const sendCbUtf8 = document.getElementById('sendCbUtf8');
const sendCbFile = document.getElementById('sendCbFile');
// const receiveCbUtf8 = document.getElementById('receiveCbUtf8');
const sendCbUtf8_data = document.getElementById('sendCbUtf8_data');
const receiveCbUtf8_data = document.getElementById('receiveCbUtf8_data');
const sendCbFile_data = document.getElementById('sendCbFile_data');
const user_input = document.getElementById('user');
const disabled_graphics_input = document.getElementById('disabledGraphics');
const verbose_input = document.getElementById('verbose');
const kbtype_input = document.getElementById('kbtype');
const jsonConfig_input = document.getElementById('jsonConfig');
const pass_input = document.getElementById('pass');
const url_input = document.getElementById('url');
const height_input = document.getElementById('height');
const width_input = document.getElementById('width');
const bpp_input = document.getElementById('bpp');
const gdimpl_input = document.getElementById('gdimpl');
const cbFmts = document.getElementById('cbFmts');
const cbFiles = document.getElementById('cbFiles');
const cbDownload = document.getElementById('cbDownload');
const permalink = document.getElementById('permalink');

let _Module;
WallixModule({
    // INITIAL_MEMORY: 16777216, // 16**6
    // INITIAL_MEMORY: 268435456, // 16**7
}).then((Module) => {

_Module = Module;

// optional
const LogLevel = Module.LogLevel;
Module.log = function(priority, msg) {
    const logger = (priority === LogLevel.Info) ? console.log
                 : (priority === LogLevel.Warning) ? console.warn
                 : (priority === LogLevel.Error) ? console.error
                 : (priority === LogLevel.Debug) ? (s) => {
                    console.debug("%c%s", 'color:yellow', s)
                 }
                 : console.info;
    logger(msg);
};

const RdpClient = Module.RdpClient;
const ClipboardChannel = Module.ClipboardChannel;
const MouseFlags = Module.MouseFlags;
const KbdFlags = Module.KbdFlags;
const InputFlags = Module.InputFlags;

function MultiSelectToInt(e, constants)
{
    let flags = 0;
    for (let i = 0; i < e.length; i++) {
        if (e.options[i].selected) {
            flags |= constants[e.options[i].value] || 0;
        }
    }
    return flags;
}

const gdImplTable = {
    '2d':newRdpGraphics2D,
    webgl:newRdpGraphicsGL,
    webgl2:newRdpGraphicsGL2,
};

const ModFlag = Object.freeze({
    NoMod: 0x10000 << 0,
    Shift: 0x10000 << 1,
    AltGr: 0x10000 << 2,
    Ctrl: 0x10000 << 3,
    ShiftAltGr: 0x10000 << 4,
    CapsLock: 0x10000 << 5,
    ShiftCapsLock: 0x10000 << 6,
    AltGrCapsLock: 0x10000 << 7,
    ShiftAltGrCapsLock: 0x10000 << 8,
});

// same name as KeyboardEvent.key
const KeyControlMap = Object.freeze({
    //      mask, scancode (left key)
    Shift: [ModFlag.Shift, 0x2A],
    Ctrl: [ModFlag.Ctrl, 0x1D],
    OS: [0x10000 << 9, 0x15B],
    // Win: [1 << 2, 0x15B], // (OS) on IE and maybe Edge
    Alt: [0x10000 << 10, 0x38],
    AltGraph: [ModFlag.AltGr, 0x138],
});

function run(openCb, closeCb)
{
    console.info('Graphics implementation: ' + gdimpl_input.value);
    const gd = gdImplTable[gdimpl_input.value](ecanvas, Module);
    gd.drawRect(0, 0, gd.width, gd.height, 0);

    const socket = new WebSocket(url_input.value, "RDP");
    socket.binaryType = 'arraybuffer';

    let rdpclient;

    let hWheelSupport = false;
    let MouseXSupport = false;
    let onKeyEvent = unicodeKeyEvent;

    const sendData = function() {
        const out = rdpclient.getOutputData();
        if (out.length) {
            socket.send(out);
            rdpclient.resetOutputData();
        }
    };

    function scancodeKeyEvent(flag, evt)
    {
        // KeyboardEvent.code available with
        // - chrome 8+
        // - edge 79+
        // - firefox 38+
        // - opera 11+
        // - safari 10+
        // Check support with `new KeyboardEvent(0).code !== undefined`

        // TODO support of special configuration as Esc <-> CapsLock (use key id code.length > 1 ?)

        const scancode = keycodeToScancode(evt.code);
        // console.log(flag, evt.key, evt.code, scancode, evt.isComposing);
        if (scancode) {
            // switch (scancode) {
            // case 0x1d: // control left
            // case 0x11d: // control right
            //     console.log('control', flag !== KbdFlags.Release);
            //     break;
            // case 0x38: // alt left
            // case 0x138: // alt right
            //     console.log('alt', flag !== KbdFlags.Release);
            //     break;
            // case 0x2a: // shift left
            // case 0x36: // shift right
            //     console.log('shift', flag !== KbdFlags.Release);
            //     break;
            // case 0x15b: // win
            //     console.log('meta', flag !== KbdFlags.Release);
            //     break;
            // }
            evt.preventDefault();
            evt.stopImmediatePropagation();
            rdpclient.writeScancodeEvent(scancode | flag);
            sendData();
        }
        else {
            const scancodes = keycodeToMultiScancodes(evt.code);
            if (scancodes) {
                evt.preventDefault();
                evt.stopImmediatePropagation();
                rdpclient.writeScancodeEvent(scancodes[0] | flag);
                rdpclient.writeScancodeEvent(scancodes[1] | flag);
                sendData();
            }
            else {
                console.warn('unknown keycode', flag, evt.key, evt.code)
            }
        }
    }

    function unicodeKeyEvent(flag, evt)
    {
        // console.log(flag, evt.key, evt.code);
        const key = evt.key;

        if (key.length === 1) {
            const unicode = key.codePointAt(0);
            // console.log(key, unicode);
            evt.preventDefault();
            evt.stopImmediatePropagation();
            rdpclient.writeUnicodeEvent(unicode, flag);
            sendData();
        }
        else if (key === 'Dead') {
            return
        }
        else {
            scancodeKeyEvent(flag, evt);
        }
    }

    let modMask = ModFlag.NoMod;
    let controlMask = ModFlag.NoMod;
    let layoutName = "fr-FR";
    // let layoutName = "en-US.international";
    let layout;
    for (let i = 0; i < layouts.length; ++i) {
        if (layouts[i].name === layoutName) {
            layout = layouts[i];
        }
    }
    let hasShiftLeft = false;
    let hasShiftRight = false;
    let isDead = false;

    function syncScancode(controlMask, scancodeFlag)
    {
        for (const k in KeyControlMap) {
            console.log(k)
            if (controlMask & KeyControlMap[k][0]) {
                console.log('sync', KeyControlMap[k][0], scancodeFlag)
                rdpclient.writeScancodeEvent(scancodeFlag | KeyControlMap[k][1]);
            }
        }
    }

    function emulateKey(controlMask, scancodes)
    {
        syncScancode(controlMask, KbdFlags.Release);
        for (let i = 0; i < scancodes.length; ++i) {
            rdpclient.writeScancodeEvent(scancodes[i]);
        }
        syncScancode(controlMask, 0);
        sendData();
    }

    function unicodeToScancodeKeyEvent(flag, evt)
    {
        console.log('reverse scancode', flag, evt.key, evt.code);

        const key = evt.key;
        if (key == 'Space') {
            key = ' ';
        }

        if (isDead) {
            if (flag) return;
            console.log('isdead')
            isDead = false;
            const codes = layout.deadmap[key];
            console.log(codes);
            if (codes) {
                const datas = codes[1];
                console.log(`data: ${datas}  controlMask: 0x${controlMask.toString(16)}`);
                const len = datas.length;
                for (let i = 0; i < len; ++i) {
                    const data = datas[i];
                    console.log(`data: 0x${data.toString(16)}`);
                    if (data & controlMask) {
                        console.log('match mod');
                        evt.preventDefault();
                        evt.stopImmediatePropagation();
                        rdpclient.writeScancodeEvent(codes[0]);
                        rdpclient.writeScancodeEvent(data & 0xff);
                        sendData();
                        return;
                    }
                }
            }
            return ;
        }

        if (key.length === 1) {
            console.log('key.len == 1');
            const datas = layout.keymap[key];
            if (datas) {
                console.log(`data: ${datas}  controlMask: 0x${controlMask.toString(16)}`);
                const len = datas.length;
                for (let i = 0; i < len; ++i) {
                    const data = datas[i];
                    console.log(`data: 0x${data.toString(16)}`);
                    if (data & controlMask) {
                        console.log('match mod');
                        evt.preventDefault();
                        evt.stopImmediatePropagation();
                        rdpclient.writeScancodeEvent(data & 0xff | flag);
                        sendData();
                        return;
                    }
                }

                // TODO don't remove ctrl
                const data = datas[0];
                const mod = data & ~0xffff;
                if (mod & ModFlag.NoMod) {
                    console.log('& nomod');
                    emulateKey(controlMask, [
                        data & 0xff | flag
                    ]);
                }
                else if (mod & ModFlag.Shift) {
                    console.log('& shift');
                    emulateKey(controlMask & ~KeyControlMap.Shift[0], [
                        KeyControlMap.Shift[1],
                        data & 0xff | flag,
                        KeyControlMap.Shift[1] | KbdFlags.Release,
                    ]);
                }
                else if (mod & ModFlag.AltGr) {
                    console.log('& altgr');
                    emulateKey(controlMask & ~KeyControlMap.AltGraph[0], [
                        KeyControlMap.AltGraph[1],
                        data & 0xff | flag,
                        KeyControlMap.AltGraph[1] | KbdFlags.Release,
                    ]);
                }
                else if (mod & ModFlag.AltGrShift) {
                    console.log('& altgr shift');
                    emulateKey(controlMask & ~(KeyControlMap.AltGraph[0] | KeyControlMap.Shift[0]), [
                        KeyControlMap.Shift[1],
                        KeyControlMap.AltGraph[1],
                        data & 0xff | flag,
                        KeyControlMap.AltGraph[1] | KbdFlags.Release,
                        KeyControlMap.Shift[1] | KbdFlags.Release,
                    ]);
                }
            }
        }
        else {
            const control = KeyControlMap[key];
            let scancode;
            switch (key) {
                case 'Dead': {
                    isDead = true;
                    return ;
                }

                case 'Shift':
                    if (flag) {
                        modMask &= ~KeyControlMap.Shift[0];
                        controlMask &= ~KeyControlMap.Shift[0];
                    }
                    else {
                        modMask |= KeyControlMap.Shift[0];
                        controlMask |= KeyControlMap.Shift[0];
                    }
                    scancode = 0x2A;
                    break;
                case 'Ctrl':
                    if (flag) {
                        if (((modMask & (KeyControlMap.Ctrl[0] | KeyControlMap.Alt[0])) == (KeyControlMap.Ctrl[0] | KeyControlMap.Alt[0]))
                         && !(modMask & KeyControlMap.AltGraph[0])) {
                            controlMask &= ~KeyControlMap.AltGraph[0];
                        }
                        modMask &= ~KeyControlMap.Ctrl[0];
                        controlMask &= ~KeyControlMap.Ctrl[0];
                    }
                    else {
                        modMask |= KeyControlMap.Ctrl[0];
                        controlMask |= KeyControlMap.Ctrl[0];
                        if (((modMask & (KeyControlMap.Ctrl[0] | KeyControlMap.Alt[0])) == (KeyControlMap.Ctrl[0] | KeyControlMap.Alt[0])) ) {
                            controlMask |= KeyControlMap.AltGraph[0];
                        }
                    }
                    scancode = 0x1D;
                    break;
                case 'Alt':
                    if (flag) {
                        if (((modMask & (KeyControlMap.Ctrl[0] | KeyControlMap.Alt[0])) == (KeyControlMap.Ctrl[0] | KeyControlMap.Alt[0]))
                         && !(modMask & KeyControlMap.AltGraph[0])) {
                            controlMask &= ~KeyControlMap.AltGraph[0];
                        }
                        modMask &= ~KeyControlMap.Alt[0];
                        controlMask &= ~KeyControlMap.Alt[0];
                    }
                    else {
                        modMask |= KeyControlMap.Alt[0];
                        controlMask |= KeyControlMap.Alt[0];
                        if (((modMask & (KeyControlMap.Ctrl[0] | KeyControlMap.Alt[0])) == (KeyControlMap.Ctrl[0] | KeyControlMap.Alt[0])) ) {
                            controlMask |= KeyControlMap.AltGraph[0];
                        }
                    }
                    scancode = 0x38;
                    break;
                case 'AltGraph':
                    if (flag) {
                        modMask &= ~KeyControlMap.AltGraph[0];
                        if (((modMask & (KeyControlMap.Ctrl[0] | KeyControlMap.Alt[0]))) != (KeyControlMap.Ctrl[0] | KeyControlMap.Alt[0])) {
                            controlMask &= ~KeyControlMap.AltGraph[0];
                        }
                    }
                    else {
                        modMask |= KeyControlMap.AltGraph[0];
                        controlMask |= KeyControlMap.AltGraph[0];
                    }
                    scancode = 0x138;
                    break;
                case 'OS':
                    if (flag) {
                        modMask &= ~KeyControlMap.OS[0];
                        controlMask &= ~KeyControlMap.OS[0];
                    }
                    else {
                        modMask |= KeyControlMap.OS[0];
                        controlMask |= KeyControlMap.OS[0];
                    }
                    scancode = 0x15B;
                    break;

                default:
                    return;
            }

            modMask &= ~ModFlag.NoMod;
            controlMask &= ~ModFlag.NoMod;
            if (!modMask) {
                modMask |= ModFlag.NoMod;
                controlMask |= ModFlag.NoMod;
            }
            console.log(`>controlMask: 0x${controlMask.toString(16)}  modMask: 0x${modMask.toString(16)}`);

            evt.preventDefault();
            evt.stopImmediatePropagation();
            rdpclient.writeScancodeEvent(scancode | flag);
            sendData();
        }
    }

    function sendMouseEvent(evt, flags)
    {
        evt.preventDefault();
        evt.stopImmediatePropagation();
        rdpclient.writeMouseEvent(evt.offsetX, evt.offsetY, flags);
        sendData();
    }

    //TODO rename KbdFlags.Down to KbdFlags.Press and add KbdFlags.Down = 0
    const onKeyUp = (evt) => { onKeyEvent(KbdFlags.Release, evt); };
    const onKeyDown = (evt) => { onKeyEvent(0, evt); };
    const onKeyPress = (evt) => { onKeyEvent(KbdFlags.Down, evt); };

    function sendMouseButton(evt, flag)
    {
        switch (evt.button) {
        case 0: return sendMouseEvent(evt, flag | MouseFlags.LeftButton);
        case 1: return sendMouseEvent(evt, flag | MouseFlags.MiddleButton);
        case 2: return sendMouseEvent(evt, flag | MouseFlags.RightButton);
        case 3: if (MouseXSupport) return sendMouseEvent(evt, flag | MouseFlags.Button4); break;
        case 4: if (MouseXSupport) return sendMouseEvent(evt, flag | MouseFlags.Button5); break;
        }
    }

    const onMouseMove = (evt) => sendMouseEvent(evt, MouseFlags.Move);
    const onMouseDown = (evt) => sendMouseButton(evt, MouseFlags.Down);
    const onMouseUp = (evt) => sendMouseButton(evt, MouseFlags.Up);
    const onMouseWheel = (evt) => {
        if (evt.deltaY) {
            const delta = (evt.deltaY < 0)
                ? MouseFlags.WheelRotationMask
                : MouseFlags.WheelNegative;
            sendMouseEvent(evt, MouseFlags.VerticalWheel | delta);
        }
        else if (evt.deltaX && hWheelSupport) {
            const delta = (evt.deltaX < 0)
                ? MouseFlags.WheelRotationMask
                : MouseFlags.WheelNegative;
            sendMouseEvent(evt, MouseFlags.HorizontalWheel | delta);
        }
    };

    const docEvents = {
        keyup: onKeyUp,
        keydown: onKeyDown,
        // TODO re-enable ?
        // keypress: onKeyPress,
    };

    const canvasEvents = {
        mousemove: onMouseMove,
        mousedown: onMouseDown,
        mouseup: onMouseUp,
        wheel: onMouseWheel,
        // TODO re-enable ?
        // contextmenu: event => {
        //     event.preventDefault();
        //     event.stopImmediatePropagation();
        // }
    };

    const canvasFocusEvents = {
        onblur: canvasBlur,
        onfocus: canvasFocus,
    };

    const eventTable = [
        [document, docEvents],
        [ecanvas, canvasEvents],
    ];

    function addEvents(elem, events)
    {
        for (let [eventName, func] of Object.entries(events)) {
            elem.addEventListener(eventName, func);
        }
    }

    function removeEvents(elem, events)
    {
        for (let [eventName, func] of Object.entries(events)) {
            elem.removeEventListener(eventName, func);
        }
    }

    function canvasStartEvents()
    {
        for (const a of eventTable) {
            addEvents(a[0], a[1]);
        }
        ecanvasFocus.onblur = canvasBlur;
        ecanvasFocus.onfocus = canvasFocus;
        canvasEnableFocus();
    }

    function canvasStopEvents()
    {
        for (const a of eventTable) {
            removeEvents(a[0], a[1]);
        }
        ecanvasFocus.onblur = () => {};
        ecanvasFocus.onfocus = () => {};
        ecanvas.onclick = () => {};
    }

    function canvasFocus()
    {
        console.log('focus');
        addEvents(document, docEvents);
        ecanvas.onclick = (e) => {
            e.preventDefault();
            e.stopImmediatePropagation();
        };
    }

    function canvasEnableFocus()
    {
        // preventScroll don't work with firefox
        ecanvasFocus.focus({preventScroll: true});
    }

    function canvasBlur()
    {
        console.log('blur');
        removeEvents(document, docEvents);
        ecanvas.onclick = canvasEnableFocus;
    }

    function updateInput()
    {
        const inputFlags = rdpclient.getInputFlags();
        const keyboardLayout = rdpclient.getKeyboardLayout();
        console.log(`keyboardLayout: 0x${keyboardLayout.toString(16)}`);
        console.group(`inputFlags: 0x${inputFlags.toString(16)}`);
        for (const k in InputFlags) {
            console.log(`${k}: ${(inputFlags & InputFlags[k]) ? 1 : 0} (0x${InputFlags[k].toString(16)})`);
        }
        console.groupEnd();
        hWheelSupport = Boolean(inputFlags & InputFlags.HorizontalWheel);
        MouseXSupport = Boolean(inputFlags & InputFlags.MouseX);

        const kbTypeId = kbtype_input.selectedIndex;
        if (kbTypeId === 0 && !(inputFlags & InputFlags.Unicode)) {
            console.log('don\'t support unicode');
            kbTypeId = 1;
        }
        console.log(`keyboardType: (${kbTypeId}) ${kbtype_input[kbTypeId].value}`);
        onKeyEvent = [unicodeKeyEvent, scancodeKeyEvent, unicodeToScancodeKeyEvent][kbTypeId];
        canvasStopEvents();
        canvasStartEvents();
    }

    const resizeCanvasBase = gd.resizeCanvas;
    gd.resizeCanvas = function(...args) {
        resizeCanvasBase.call(gd, ...args);
        updateInput();
    };

    const channels = [];

    const addChannel = function(channel) {
        channels.push(channel);
        rdpclient.addChannelReceiver(channel.getChannelReceiver());
    }

    let isClosed = false;

    socket.onopen = function(event) {
        const config = Object.assign({
            width: Number(width_input.value),
            height: Number(height_input.value),
            bpp: Number(bpp_input.value),
            disabledGraphicOrders: MultiSelectToInt(disabled_graphics_input, Module.GraphicOrders),
            username: user_input.value,
            password: pass_input.value,
            // getRandomValues: (data) => crypto.getRandomValues(data),
            verbose: Number(verbose_input.value) || 0/*0x04000000*/,
        }, JSON.parse(jsonConfig_input.value || '{}'));

        console.table(config);

        rdpclient = new RdpClient(gd, config);

        const cliprdr = new Cliprdr(cbFiles, sendData, Module);
        const clipboard = new ClipboardChannel(
            rdpclient.getCallbackAsVoidPtr(),
            cliprdr,
            /*verbose = */0x04000000);
        cliprdr.setEmcChannel(clipboard);
        addChannel(clipboard);

        sendCbUtf8.onsubmit = (e) => {
            e.preventDefault();
            e.stopImmediatePropagation();
            clipboard.sendFormat(CF.UNICODETEXT, 0, "");
            sendData();
        };

        sendCbFile.onsubmit = (e) => {
            e.preventDefault();
            e.stopImmediatePropagation();
            // TODO this is not Unicode
            clipboard.sendFormat(CustomCF.FileGroupDescriptorW, Charset.Unicode, "FileGroupDescriptorW");
            sendData();
        };

        socket.onmessage = function(event) {
            rdpclient.processInputData(event.data);
            sendData();
        };

        socket.onerror = function(event) {
            console.log('RdpClient error: ', event);
            socket.close();
        };

        socket.onclose = function(event) {
            console.log('RdpClient close');
            rdpclient.delete();
            // gd.delete();
            for (const channel of channels) {
                channel.delete();
            }
            canvasStopEvents();
            isClosed = true;

            gd.delete();

            closeCb();
        };

        rdpclient.writeFirstPacket();
        sendData();

        openCb();
    }

    return () => {
        if (!isClosed) {
            gd.drawRect(0, 0, gd.width, gd.height, 0);
            socket.close();
            isClosed = true;
        }
    };
}

const url = new URL(window.location.href);

urlparams = {};
function updatePermalink()
{
    let newurl = url.href.substr(0, url.href.length-url.search.length);
    newurl += '?';
    for (const k in urlparams) {
        newurl += `${k}=${urlparams[k]}&`;
    }
    permalink.href=newurl;
}

const identity = (x) => x;
const isTrue = (x) => x === 'true';
const number = (x) => Number(x) || 0;
const inputs = {
    user: [user_input, 'value', identity],
    pass: [pass_input, 'value', identity],
    url: [url_input, 'value', identity],
    width: [width_input, 'value', number],
    height: [height_input, 'value', number],
    verbose: [verbose_input, 'value', number],
    config: [jsonConfig_input, 'value', identity],
    kbtype: [kbtype_input, 'selectedIndex', identity],
    bpp: [bpp_input, 'selectedIndex', parseInt],
    gdimpl: [gdimpl_input, 'selectedIndex', identity],
};
for (const k in inputs) {
    const d = inputs[k];
    const input = d[0];
    const mem = d[1];
    const x = d[2](url.searchParams.get(k));
    urlparams[k] = input[mem] = x;
    input.addEventListener('input', (e) => {
        urlparams[k] = input[mem];
        updatePermalink();
    }, false);
}

const selectFlags = {
    disabledGraphics: [disabled_graphics_input, Module.GraphicOrders],
}
for (const k in selectFlags) {
    const x = parseInt(url.searchParams.get(k));
    const select = selectFlags[k][0];
    const flags = selectFlags[k][1];

    const opt = document.createElement('option');
    opt.textContent = 'None (0x00)';
    select.appendChild(opt);
    if (!x) {
        opt.selected = true;
    }

    for (name in flags) {
        const opt = document.createElement('option');
        const flag = flags[name];
        opt.value = name;
        opt.textContent = `${name} (0x${flag.toString(2).length.toString(16).padStart(2, '0')})`;
        select.appendChild(opt);
        if (x & flag) {
            opt.selected = true;
        }
    }

    urlparams[k] = x;
    select.addEventListener('input', (e) => {
        urlparams[k] = MultiSelectToInt(select, flags);
        updatePermalink();
    }, false);
}

updatePermalink();


let currentGdImpl = gdimpl_input.selectedIndex;

let closeClient = ()=>{};
let previousConnCtx = {};
function openClient()
{
    const newGdImpl = gdimpl_input.selectedIndex;
    if (currentGdImpl != newGdImpl) {
        currentGdImpl = newGdImpl;
        newCanvas = document.createElement('canvas');
        newCanvas.width = Number(width_input.value) || 800;
        newCanvas.height = Number(height_input.value) || 600;
        ecanvas.replaceWith(newCanvas);
        ecanvas = newCanvas;
    }

    disconnectButton.disabled = true;

    previousConnCtx.disconnectButton = {};
    const connCtx = {disconnectButton};
    previousConnCtx = connCtx;
    closeClient();
    closeClient = run(
        () => { connCtx.disconnectButton.disabled = false; },
        () => { connCtx.disconnectButton.disabled = true; },
    );
};

login.onsubmit = (e) => {
    e.preventDefault();
    e.stopImmediatePropagation();
    openClient();
};

disconnectButton.onclick = (e) => {
    e.preventDefault();
    e.stopImmediatePropagation();
    closeClient();
};

openClient();

});
// const bytearray = new Uint8Array(event.data)
// let text = ""
// // console.log('Received Binary Message of ' + bytearray.length + ' bytes')
// for (let byte of bytearray) {
//     text += ":" + (byte+0x10000).toString(16).substr(-2)
// }
// console.log("Server Says: " + text)
</script>

</body>
</html>
