<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        body {
            display: flex;
        }
        form {
            /* display:inline; */
            /* vertical-align:top; */
            margin-bottom: 2em
        }

        input {
            /* display: flex; */
            /* flex-direction: column; */
        }

        section {
            background: cyan
        }
    </style>
</head>
<body>

<div>
<canvas id="canvas" width="800" height="600"></canvas>
<input id="canvasFocus" type="text"/>
<style>
#canvasFocus {
    width: 0px;
    height: 0px;
    position: relative;
    z-index: -10;
    top: -800px;
}
#cbDownload {
    display: hidden
}
#login, fieldset {
    column-count: auto;
}
#login label {
    display: inline-block
}
</style>
</div>
<section>
    <form id="login" method="get" action="#">
        <fieldset>
            <legend>Connection</legend>
            <label for="ws">url: <input type="url" id="ws" name="ws" value="ws://localhost:3390" placeholder="websocket"/></label>
            <label for="user">User: <input type="text" id="user" name="user" value="x" placeholder="Username"/></label>
            <label for="pass">Pass: <input type="text" id="pass" name="pass" value="x" placeholder="Password"/></label>
        </fieldset>
        <fieldset>
            <legend>Graphique</legend>
            <label for="width">width: <input type="number" id="width" name="width" value="800" placeholder="Width"/></label>
            <label for="height">height: <input type="number" id="height" name="height" value="600" placeholder="Height"/></label>
            <label for="bpp">bpp: <select name="bpp" id="bpp">
                <option value="8">8</option>
                <option value="15">15</option>
                <option value="16" selected="selected">16</option>
                <option value="24">24</option>
                <option value="32">32</option>
            </select></label>
            <label for="disabledGraphics">disabled: <select name="disabledGraphics" id="disabledGraphics" multiple>
            </select></label>
        </fieldset>
        <fieldset>
            <legend>Autres</legend>
            <label for="verbose">verbose: <input type="text" id="verbose" name="verbose" placeholder="Verbose"/></label>
        </fieldset>
        <input type="submit" value="New Connection">
    </form>
    <form id="disconnect" method="get" action="#">
        <input type="submit" disabled="disabled" value="Disconnect">
    </form>
    <form id="sendCbFile" method="get" action="#">
        <input id="sendCbFile_data" name="myFile" type="file">
        <input type="submit" value="Send File">
    </form>
    <form id="sendCbUtf8" method="get" action="#">
        <textarea id="sendCbUtf8_data"></textarea>
        <input type="submit" value="Send Clipboard">
    </form>
    <!-- <form id="receiveCbUtf8" method="get" action="#"> -->
        <!-- <input type="submit" value="Send Clipboard"> -->
        <textarea id="receiveCbUtf8_data"></textarea>
    <!-- </form> -->
    <p id="cbFmts"></p>
    <p id="cbFiles"></p>
    <a id="cbDownload"></a>

<section>

<script src="js_client.js"></script>
<script src="to_scancode.js"></script>
<script src="rdp_graphics.js"></script>
<script src="out_stream.js"></script>
<script src="clipboard.js"></script>

<script>
let _Module;

WallixModule({
    // INITIAL_MEMORY: 16777216, // 16**6
    // INITIAL_MEMORY: 268435456, // 16**7
}).then((Module) => {

_Module = Module;

// optional
console.log(Module.LogLevel)
Module.log = function(priority, msg) {
    const logger = (priority === Module.LogLevel.Info) ? console.log
                 : (priority === Module.LogLevel.Warning) ? console.warn
                 : (priority === Module.LogLevel.Error) ? console.error
                 : (priority === Module.LogLevel.Debug) ? console.debug
                 : console.log;
    logger(msg);
};

const RdpClient = Module.RdpClient;
const ClipboardChannel = Module.ClipboardChannel;
const HEAPU8 = Module.HEAPU8;
const HEAPU16 = Module.HEAPU16;


const ecanvasFocus = document.getElementById('canvasFocus');
const ecanvas = document.getElementById('canvas');
const canvas = ecanvas.getContext('2d');
const login = document.getElementById('login');
const disconnectButton = document.getElementById('disconnect');
const sendCbUtf8 = document.getElementById('sendCbUtf8');
const sendCbFile = document.getElementById('sendCbFile');
// const receiveCbUtf8 = document.getElementById('receiveCbUtf8');
const sendCbUtf8_data = document.getElementById('sendCbUtf8_data');
const receiveCbUtf8_data = document.getElementById('receiveCbUtf8_data');
const sendCbFile_data = document.getElementById('sendCbFile_data');
const user_input = document.getElementById('user');
const disabled_graphics_input = document.getElementById('disabledGraphics');
const verbose_input = document.getElementById('verbose');
const pass_input = document.getElementById('pass');
const ws_input = document.getElementById('ws');
const height_input = document.getElementById('height');
const width_input = document.getElementById('width');
const bpp_input = document.getElementById('bpp');
const cbFmts = document.getElementById('cbFmts');
const cbFiles = document.getElementById('cbFiles');
const cbDownload = document.getElementById('cbDownload');

const KbdFlags = Object.freeze({
    Extended: 0x0100,
    Extended1: 0x0200,
    Down: 0x4000,
    Release: 0x8000,
});

function mouseButtonToFlag(evt)
{
    switch (evt.button) {
    case 0: return 0x1000; // left button
    case 1: return 0x4000; // middle button
    case 2: return 0x2000; // right button
    // case 3: return 0x0001;
    // case 4: return 0x0002;
    }
    return 0x1000;
}

function MultiSelectToInt(e, constants)
{
    let flags = 0;
    for (let i = 0; i < e.length; i++) {
        if (e.options[i].selected) {
            console.log()
            flags |= constants[e.options[i].value];
        }
    }
    return flags;
}

const gd = new RDPGraphics(ecanvas, Module);

function run()
{
    const socket = new WebSocket(ws_input.value, "RDP");
    socket.binaryType = 'arraybuffer';

    let rdpclient;

    const sendData = function() {
        const out = rdpclient.getOutputData();
        if (out.length) {
            socket.send(out);
            rdpclient.resetOutputData();
        }
    };

    function onKeyEvent(flag, evt)
    {
        const scancode = toScancode(evt.code);
        // console.log(flag, evt.key, evt.code, scancode)
        if (scancode) {
            // switch (scancode) {
            // case 0x1d: // control left
            // case 0x11d: // control right
            //     console.log('control', flag !== KbdFlags.Release);
            //     break;
            // case 0x38: // alt left
            // case 0x138: // alt right
            //     console.log('alt', flag !== KbdFlags.Release);
            //     break;
            // case 0x2a: // shift left
            // case 0x36: // shift right
            //     console.log('shift', flag !== KbdFlags.Release);
            //     break;
            // case 0x15b: // win
            //     console.log('meta', flag !== KbdFlags.Release);
            //     break;
            // }
            evt.preventDefault();
            rdpclient.writeScancodeEvent(scancode | flag);
            sendData();
        }
        // else {
        //     console.log(flag, evt.key, evt.keyCode)
        // }
    }

    function onMouseEvent(flag, evt)
    {
        evt.preventDefault();
        // console.log(evt.offsetX, evt.offsetY, evt.button)
        // console.log(flag, evt.button)
        rdpclient.writeMouseEvent(evt.offsetX, evt.offsetY, flag | mouseButtonToFlag(evt));
        sendData();
    }


    const onKeyUp = (evt) => { onKeyEvent(KbdFlags.Release, evt); };
    const onKeyDown = (evt) => { onKeyEvent(0, evt); };
    const onKeyPress = (evt) => { onKeyEvent(KbdFlags.Down, evt); };

    const onMouseMove = (evt) => {
        evt.preventDefault();
        // console.log(evt.offsetX, evt.offsetY, evt.button)
        rdpclient.writeMouseEvent(evt.offsetX, evt.offsetY, 0x0800);
    };
    const onMouseDown = (evt) => { onMouseEvent(0x8000, evt); };
    const onMouseUp = (evt) => { onMouseEvent(0, evt); };
    const onMouseWheel = (evt) => {
        evt.preventDefault();
        // 0x200 | delta
        rdpclient.writeMouseEvent(0, 0, (evt.deltaY < 0) ? 0x287 : 0x388);
    };

    const docEvents = {
        keyup: onKeyUp,
        keydown: onKeyDown,
        keypress: onKeyPress,
    };

    const canvasEvents = {
        mousemove: onMouseMove,
        mousedown: onMouseDown,
        mouseup: onMouseUp,
        wheel: onMouseWheel,
        contextmenu: event => event.preventDefault()
    };

    const canvasFocusEvents = {
        onblur: canvasBlur,
        onfocus: canvasFocus,
    };

    const eventTable = [
        [document, docEvents],
        [ecanvas, canvasEvents],
    ];

    function addEvents(elem, events)
    {
        for (let [eventName, func] of Object.entries(events)) {
            elem.addEventListener(eventName, func);
        }
    }

    function removeEvents(elem, events)
    {
        for (let [eventName, func] of Object.entries(events)) {
            elem.removeEventListener(eventName, func);
        }
    }

    function canvasStartEvents()
    {
        for (const a of eventTable) {
            addEvents(a[0], a[1]);
        }
        ecanvasFocus.onblur = canvasBlur;
        ecanvasFocus.onfocus = canvasFocus;
        canvasEnableFocus();
    }

    function canvasStopEvents()
    {
        for (const a of eventTable) {
            removeEvents(a[0], a[1]);
        }
        ecanvasFocus.onblur = () => {};
        ecanvasFocus.onfocus = () => {};
        ecanvas.onclick = () => {};
    }

    function canvasFocus()
    {
        console.log('focus');
        addEvents(document, docEvents);
        ecanvas.onclick = (e) => e.preventDefault();
    }

    function canvasEnableFocus()
    {
        // preventScroll don't work with firefox
        ecanvasFocus.focus({preventScroll: true});
    }

    function canvasBlur()
    {
        console.log('blur');
        removeEvents(document, docEvents);
        ecanvas.onclick = canvasEnableFocus;
    }

    const channels = [];

    const addChannel = function(channel) {
        channels.push(channel);
        rdpclient.addChannelReceiver(channel.getChannelReceiver());
    }

    const socketState = {socket: socket, isClosed: false};

    socket.onopen = function(event) {
        console.log('RdpClient open');

        disconnectButton.onsubmit = (e) => {
            e.preventDefault();
            gd.drawRect(0, 0, gd.width, gd.height, 0);
            socket.close();
        };
        disconnectButton.firstElementChild.disabled = false;

        rdpclient = new RdpClient(gd, {
            width: Number(width_input.value),
            height: Number(height_input.value),
            bpp: Number(bpp_input.value),
            disabledGraphicOrders: MultiSelectToInt(disabled_graphics_input, Module.GraphicOrders),
            username: user_input.value,
            password: pass_input.value,
            // getRandomValues: (data) => crypto.getRandomValues(data),
            verbose: Number(verbose_input.value) || 0/*0x04000000*/,
        });

        const cliprdr = new Cliprdr(cbFiles, sendData, Module);
        const clipboard = new ClipboardChannel(
            rdpclient.getCallbackAsVoidPtr(),
            cliprdr,
            /*verbose = */0x04000000);
        cliprdr.setEmcChannel(clipboard);
        addChannel(clipboard);

        sendCbUtf8.onsubmit = (e) => {
            e.preventDefault();
            clipboard.sendFormat(CF.UNICODETEXT, 0, "");
            sendData();
        };

        sendCbFile.onsubmit = (e) => {
            e.preventDefault();
            // TODO this is not Unicode
            clipboard.sendFormat(CustomCF.FileGroupDescriptorW, Charset.Unicode, "FileGroupDescriptorW");
            sendData();
        };

        socket.onmessage = function(event) {
            rdpclient.processInputData(event.data);
            sendData();
        };

        socket.onerror = function(event) {
            console.log('RdpClient error: ', event);
            socket.close();
        };

        socket.onclose = function(event) {
            console.log('RdpClient close');
            disconnectButton.firstElementChild.disabled = true;
            rdpclient.delete();
            // gd.delete();
            for (const channel of channels) {
                channel.delete();
            }
            canvasStopEvents();
            socketState.isClosed = true;
        };

        rdpclient.writeFirstPacket();
        sendData();

        canvasStartEvents();
    }

    return socketState;
}

socketState = {isClosed: true};

login.onsubmit = (e) => {
    e.preventDefault();
    if (!socketState.isClosed) {
        socketState.socket.close();
    }
    socketState = run();
};


gd.drawRect(0, 0, gd.width, gd.height, 0);


const url = new URL(window.location.href);

const inputs = {
    user: user_input,
    pass: pass_input,
    ws: ws_input,
    width: width_input,
    height: height_input,
};
for (const k in inputs) {
    const x = url.searchParams.get(k);
    if (x) {
        inputs[k].value = x;
    }
}

const selects = {
    bpp: bpp_input,
    verbose: verbose_input,
};
for (const k in selects) {
    const x = parseInt(url.searchParams.get(k));
    if (x >= 0) {
        selects[k].selectedIndex = x;
    }
}

const selectFlags = {
    disabledGraphics: [disabled_graphics_input, Module.GraphicOrders],
}
for (const k in selectFlags) {
    const x = parseInt(url.searchParams.get(k));
    const select = selectFlags[k][0];
    const flags = selectFlags[k][1];
    for (name in flags) {
        const opt = document.createElement('option');
        const flag = flags[name];
        opt.value = name;
        opt.textContent = `${name} (0x${flag.toString(2).length.toString(16).padStart(2, '0')})`;
        select.appendChild(opt);
        if (x & flag) {
            opt.selected = "selected";
        }
    }
}

socketState = run();

});
// const bytearray = new Uint8Array(event.data)
// let text = ""
// // console.log('Received Binary Message of ' + bytearray.length + ' bytes')
// for (let byte of bytearray) {
//     text += ":" + (byte+0x10000).toString(16).substr(-2)
// }
// console.log("Server Says: " + text)
</script>

</body>
</html>
