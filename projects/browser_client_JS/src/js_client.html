<!doctype html>
<html>
<head>
  <meta charset="utf-8">
</head>
<body>

<canvas id="canvas" width="800" height="600"></canvas>
<button id="newco" style="vertical-align:top">New Connection</button>
<script>
const canvas = document.getElementById('canvas').getContext('2d');
const newcobutton = document.getElementById('newco');
let client;
newcobutton.onclick = () => {
    client.close();
    Module.onRuntimeInitialized();
};

(function(context) {
    const identity = (x) => x;
    const wrappersCb = {
        drawImage: function(cb) {
            return function(idata, w, h, dx, dy, sz, sy, dw, dh) {
                const data = HEAPU8.subarray(idata, idata + w * h * 4);
                const image = new ImageData(new Uint8ClampedArray(data), w, h);
                cb(image, dx, dy, 0, 0, dw, dh);
            };
        },

        socketOpen: identity,
        socketClose: identity,
        socketMessage: identity,
        socketError: identity,
        socketSend: identity,
    }

    context.RdpClientEventTable = {};

    const noop = function(){};

    context.createRdpClient = function(url, verbosity) {
        const socket = new WebSocket(url, "RDP")
        socket.binaryType = 'arraybuffer';

        let rdpclient = null;
        const events = {};

        const client = {
            on: function(eventName, cb) {
                const wrapCb = wrappersCb[eventName];
                if (!wrapCb) {
                    console.log('RdpClient: Unknown event ' + eventName);
                    return false;
                }
                events[eventName] = wrapCb(cb);
                return this;
            },
            close: noop
        };

        const send_data = function() {
            const out = rdpclient.getSendingData()
            if (out.length) {
                // console.log("send " + out.length + " bytes")
                const cb = events.socketSend
                if (cb) {
                    cb(out)
                }
                socket.send(out)
                rdpclient.clearSendingData()
            }
        };

        let timeoutID = -1;
        let timeoutDate = 0xffffffff;
        const timer_action = function() {
            const now = Data.now();
            const timeout = rdpclient.updateTime();
            send_data();
            timeoutDate = now + timeout;
            timeoutID = setTimeout(timer_action, timeout);
        }
        const update_timer = function(nextDate) {
            if (nextDate < timeoutDate) {
                timeoutDate = nextDate;
                clearTimeout(timeoutID);
                timeoutID = setTimeout(timer_action, Math.max(0, nextDate - Data.now()));
            }
        }

        const finally_ = function(cb, event) {
            try {
                if (cb) {
                    cb(event);
                }
            }
            finally {
                if (rdpclient) {
                    if (timeoutID) {
                        clearTimeout(timeoutID)
                    }
                    rdpclient.delete()
                    rdpclient = null
                }
            }
        }

        socket.onopen = function(event) {
            const cb = events.socketOpen
            if (cb) {
                cb(event)
            }
            client.close = function() {
                socket.close()
            };
            rdpclient = new Module.RdpClient(verbosity || 0);

            context.RdpClientEventTable[rdpclient.thisptr()] = events;

            rdpclient.updateTime();
            timeoutDate = Date.now();
            send_data()
        };

        socket.onmessage = function(event) {
            const cb = events.socketMessage
            if (cb) {
                cb(event)
            }
            rdpclient.addReceivingData(event.data)
            const now = Date.now()
            const timeout = rdpclient.updateTime()
            send_data()
            const nextDateTimer = now + timeout;
            if (nextDateTimer < timeoutDate) {
                timeoutDate = nextDateTimer;
                clearTimeout(timeoutID);
                timeoutID = setTimeout(timer_action, Math.max(0, nextDateTimer - Data.now()));
            }
        };

        socket.onerror = function(event) {
            finally_(events.socketError);
        };

        socket.onclose = function(event) {
            finally_(events.socketClose);
        };

        return client;
    }
})(window)

var Module = {
  TOTAL_MEMORY: 268435456, // 16**7
  onRuntimeInitialized: function() {
    const rdpclient = createRdpClient("ws://localhost:8080", 0/*xff*/)
    rdpclient.on('drawImage', canvas.putImageData.bind(canvas))
    rdpclient.on('socketClose', () => console.log('RdpClient close'))
    client = rdpclient

    canvas.fillStyle = 0xffff00
    canvas.fillRect(0,0,800,600)
            // const bytearray = new Uint8Array(event.data)
            // let text = ""
            // // console.log('Received Binary Message of ' + bytearray.length + ' bytes')
            // for (let byte of bytearray) {
            //     text += ":" + (byte+0x10000).toString(16).substr(-2)
            // }
            // console.log("Server Says: " + text)
  }
};
</script>
<script src="js_client.js"></script>

</body>
</html>
