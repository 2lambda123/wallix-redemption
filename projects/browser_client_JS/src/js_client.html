<!doctype html>
<html>
<head>
    <meta charset="utf-8">
</head>
<body>

<canvas id="canvas" width="800" height="600"></canvas>
<form id="login" method="get" action="#" style="display:inline;vertical-align:top">
    <input type="text" id="user" name="user" value="x" placeholder="Username"/>
    <input type="text" id="pass" name="pass" value="x" placeholder="Password"/>
    <input type="submit" value="New Connection">
</form>

<script src="js_client.js"></script>
<script>
const Module = WallixModule({
    TOTAL_MEMORY: 268435456, // 16**7
});

const createRdpClient = (function(Module) {
    const HEAPU8 = Module.HEAPU8;
    const identity = (x) => x;
    const wrappersCb = {
        drawImage: function(cb) {
            return function(idata, w, h, dx, dy, sz, sy, dw, dh) {
                const data = HEAPU8.subarray(idata, idata + w * h * 4);
                const image = new ImageData(new Uint8ClampedArray(data), w, h);
                cb(image, dx, dy, 0, 0, dw, dh);
            };
        },

        socketOpen: identity,
        socketClose: identity,
        socketMessage: identity,
        socketError: identity,
        socketSend: identity,
    }

    Module.RdpClientEventTable = {};

    const noop = function(){};

    return function(url, username, password, verbosity) {
        const socket = new WebSocket(url, "RDP");
        socket.binaryType = 'arraybuffer';

        let rdpclient = null;
        const events = {};

        const client = {
            on: function(eventName, cb) {
                const wrapCb = wrappersCb[eventName];
                if (!wrapCb) {
                    console.log('RdpClient: Unknown event ' + eventName);
                    return false;
                }
                events[eventName] = wrapCb(cb);
                return this;
            },
            close: noop
        };

        const send_data = function() {
            const out = rdpclient.getSendingData()
            if (out.length) {
                // console.log("send " + out.length + " bytes")
                const cb = events.socketSend;
                if (cb) {
                    cb(out);
                }
                socket.send(out);
                rdpclient.clearSendingData();
            }
        };

        let timeoutID = -1;
        let timeoutDate = 0xffffffff;
        const timer_action = function() {
            const now = Data.now();
            const timeout = rdpclient.updateTime();
            send_data();
            timeoutDate = now + timeout;
            timeoutID = setTimeout(timer_action, timeout);
        }
        const update_timer = function(nextDate) {
            if (nextDate < timeoutDate) {
                timeoutDate = nextDate;
                clearTimeout(timeoutID);
                timeoutID = setTimeout(timer_action, Math.max(0, nextDate - Data.now()));
            }
        }

        const finally_ = function(cb, event) {
            try {
                if (cb) {
                    cb(event);
                }
            }
            finally {
                if (rdpclient) {
                    if (timeoutID) {
                        clearTimeout(timeoutID);
                    }
                    rdpclient.delete();
                    rdpclient = null;
                }
            }
        }

        socket.onopen = function(event) {
            const cb = events.socketOpen;
            if (cb) {
                cb(event);
            }
            client.close = function() {
                socket.close();
            };
            rdpclient = new Module.RdpClient(username || "", password || "", verbosity || 0);

            Module.RdpClientEventTable[rdpclient.thisptr()] = events;

            rdpclient.updateTime();
            timeoutDate = Date.now();
            send_data();
        };

        socket.onmessage = function(event) {
            const cb = events.socketMessage;
            if (cb) {
                cb(event);
            }
            rdpclient.addReceivingData(event.data);
            const now = Date.now();
            const timeout = rdpclient.updateTime();
            send_data();
            const nextDateTimer = now + timeout;
            if (nextDateTimer < timeoutDate) {
                timeoutDate = nextDateTimer;
                clearTimeout(timeoutID);
                timeoutID = setTimeout(timer_action, Math.max(0, nextDateTimer - Data.now()));
            }
        };

        socket.onerror = function(event) {
            finally_(events.socketError);
        };

        socket.onclose = function(event) {
            finally_(events.socketClose);
        };

        return client;
    }
})(Module);

const canvas = document.getElementById('canvas').getContext('2d');
const login = document.getElementById('login');
const user_input = document.getElementById('user');
const pass_input = document.getElementById('pass');
let rdpclient;

function run() {
    rdpclient = createRdpClient(
        "ws://localhost:8080",
        user_input.value,
        pass_input.value,
        0/*xff*/);
    rdpclient.on('drawImage', canvas.putImageData.bind(canvas));
    rdpclient.on('socketClose', () => console.log('RdpClient close'));
}

login.onsubmit = (e) => {
    e.preventDefault();
    if (rdpclient) {
        rdpclient.close();
    }
    run();
};

canvas.fillStyle = 0xffff00;
canvas.fillRect(0,0,800,600);

const stringvalues = document.URL.split('?')[1];
if (stringvalues) {
    const inputs = {user: user_input, pass: pass_input};
    for (const strvalue of stringvalues.split('&')) {
        const kv = strvalue.split('=');
        const input = inputs[kv[0]]
        if (input) {
            input.value = kv[1].replace('#')
        }
    }
}

run();

// const bytearray = new Uint8Array(event.data)
// let text = ""
// // console.log('Received Binary Message of ' + bytearray.length + ' bytes')
// for (let byte of bytearray) {
//     text += ":" + (byte+0x10000).toString(16).substr(-2)
// }
// console.log("Server Says: " + text)
</script>

</body>
</html>
